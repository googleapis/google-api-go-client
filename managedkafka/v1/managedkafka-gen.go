// Copyright 2025 Google LLC.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated file. DO NOT EDIT.

// Package managedkafka provides access to the Managed Service for Apache Kafka API.
//
// For product documentation, see: https://cloud.google.com/managed-service-for-apache-kafka/docs
//
// # Library status
//
// These client libraries are officially supported by Google. However, this
// library is considered complete and is in maintenance mode. This means
// that we will address critical bugs and security issues but will not add
// any new features.
//
// When possible, we recommend using our newer
// [Cloud Client Libraries for Go](https://pkg.go.dev/cloud.google.com/go)
// that are still actively being worked and iterated on.
//
// # Creating a client
//
// Usage example:
//
//	import "google.golang.org/api/managedkafka/v1"
//	...
//	ctx := context.Background()
//	managedkafkaService, err := managedkafka.NewService(ctx)
//
// In this example, Google Application Default Credentials are used for
// authentication. For information on how to create and obtain Application
// Default Credentials, see https://developers.google.com/identity/protocols/application-default-credentials.
//
// # Other authentication options
//
// To use an API key for authentication (note: some APIs do not support API
// keys), use [google.golang.org/api/option.WithAPIKey]:
//
//	managedkafkaService, err := managedkafka.NewService(ctx, option.WithAPIKey("AIza..."))
//
// To use an OAuth token (e.g., a user token obtained via a three-legged OAuth
// flow, use [google.golang.org/api/option.WithTokenSource]:
//
//	config := &oauth2.Config{...}
//	// ...
//	token, err := config.Exchange(ctx, ...)
//	managedkafkaService, err := managedkafka.NewService(ctx, option.WithTokenSource(config.TokenSource(ctx, token)))
//
// See [google.golang.org/api/option.ClientOption] for details on options.
package managedkafka // import "google.golang.org/api/managedkafka/v1"

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/googleapis/gax-go/v2/internallog"
	googleapi "google.golang.org/api/googleapi"
	internal "google.golang.org/api/internal"
	gensupport "google.golang.org/api/internal/gensupport"
	option "google.golang.org/api/option"
	internaloption "google.golang.org/api/option/internaloption"
	htransport "google.golang.org/api/transport/http"
)

// Always reference these packages, just in case the auto-generated code
// below doesn't.
var _ = bytes.NewBuffer
var _ = strconv.Itoa
var _ = fmt.Sprintf
var _ = json.NewDecoder
var _ = io.Copy
var _ = url.Parse
var _ = gensupport.MarshalJSON
var _ = googleapi.Version
var _ = errors.New
var _ = strings.Replace
var _ = context.Canceled
var _ = internaloption.WithDefaultEndpoint
var _ = internal.Version
var _ = internallog.New

const apiId = "managedkafka:v1"
const apiName = "managedkafka"
const apiVersion = "v1"
const basePath = "https://managedkafka.googleapis.com/"
const basePathTemplate = "https://managedkafka.UNIVERSE_DOMAIN/"
const mtlsBasePath = "https://managedkafka.mtls.googleapis.com/"

// OAuth2 scopes used by this API.
const (
	// See, edit, configure, and delete your Google Cloud data and see the email
	// address for your Google Account.
	CloudPlatformScope = "https://www.googleapis.com/auth/cloud-platform"
)

// NewService creates a new Service.
func NewService(ctx context.Context, opts ...option.ClientOption) (*Service, error) {
	scopesOption := internaloption.WithDefaultScopes(
		"https://www.googleapis.com/auth/cloud-platform",
	)
	// NOTE: prepend, so we don't override user-specified scopes.
	opts = append([]option.ClientOption{scopesOption}, opts...)
	opts = append(opts, internaloption.WithDefaultEndpoint(basePath))
	opts = append(opts, internaloption.WithDefaultEndpointTemplate(basePathTemplate))
	opts = append(opts, internaloption.WithDefaultMTLSEndpoint(mtlsBasePath))
	opts = append(opts, internaloption.EnableNewAuthLibrary())
	client, endpoint, err := htransport.NewClient(ctx, opts...)
	if err != nil {
		return nil, err
	}
	s := &Service{client: client, BasePath: basePath, logger: internaloption.GetLogger(opts)}
	s.Projects = NewProjectsService(s)
	if endpoint != "" {
		s.BasePath = endpoint
	}
	return s, nil
}

// New creates a new Service. It uses the provided http.Client for requests.
//
// Deprecated: please use NewService instead.
// To provide a custom HTTP client, use option.WithHTTPClient.
// If you are using google.golang.org/api/googleapis/transport.APIKey, use option.WithAPIKey with NewService instead.
func New(client *http.Client) (*Service, error) {
	if client == nil {
		return nil, errors.New("client is nil")
	}
	return NewService(context.TODO(), option.WithHTTPClient(client))
}

type Service struct {
	client    *http.Client
	logger    *slog.Logger
	BasePath  string // API endpoint base URL
	UserAgent string // optional additional User-Agent fragment

	Projects *ProjectsService
}

func (s *Service) userAgent() string {
	if s.UserAgent == "" {
		return googleapi.UserAgent
	}
	return googleapi.UserAgent + " " + s.UserAgent
}

func NewProjectsService(s *Service) *ProjectsService {
	rs := &ProjectsService{s: s}
	rs.Locations = NewProjectsLocationsService(s)
	return rs
}

type ProjectsService struct {
	s *Service

	Locations *ProjectsLocationsService
}

func NewProjectsLocationsService(s *Service) *ProjectsLocationsService {
	rs := &ProjectsLocationsService{s: s}
	rs.Clusters = NewProjectsLocationsClustersService(s)
	rs.ConnectClusters = NewProjectsLocationsConnectClustersService(s)
	rs.Operations = NewProjectsLocationsOperationsService(s)
	rs.SchemaRegistries = NewProjectsLocationsSchemaRegistriesService(s)
	return rs
}

type ProjectsLocationsService struct {
	s *Service

	Clusters *ProjectsLocationsClustersService

	ConnectClusters *ProjectsLocationsConnectClustersService

	Operations *ProjectsLocationsOperationsService

	SchemaRegistries *ProjectsLocationsSchemaRegistriesService
}

func NewProjectsLocationsClustersService(s *Service) *ProjectsLocationsClustersService {
	rs := &ProjectsLocationsClustersService{s: s}
	rs.Acls = NewProjectsLocationsClustersAclsService(s)
	rs.ConsumerGroups = NewProjectsLocationsClustersConsumerGroupsService(s)
	rs.Topics = NewProjectsLocationsClustersTopicsService(s)
	return rs
}

type ProjectsLocationsClustersService struct {
	s *Service

	Acls *ProjectsLocationsClustersAclsService

	ConsumerGroups *ProjectsLocationsClustersConsumerGroupsService

	Topics *ProjectsLocationsClustersTopicsService
}

func NewProjectsLocationsClustersAclsService(s *Service) *ProjectsLocationsClustersAclsService {
	rs := &ProjectsLocationsClustersAclsService{s: s}
	return rs
}

type ProjectsLocationsClustersAclsService struct {
	s *Service
}

func NewProjectsLocationsClustersConsumerGroupsService(s *Service) *ProjectsLocationsClustersConsumerGroupsService {
	rs := &ProjectsLocationsClustersConsumerGroupsService{s: s}
	return rs
}

type ProjectsLocationsClustersConsumerGroupsService struct {
	s *Service
}

func NewProjectsLocationsClustersTopicsService(s *Service) *ProjectsLocationsClustersTopicsService {
	rs := &ProjectsLocationsClustersTopicsService{s: s}
	return rs
}

type ProjectsLocationsClustersTopicsService struct {
	s *Service
}

func NewProjectsLocationsConnectClustersService(s *Service) *ProjectsLocationsConnectClustersService {
	rs := &ProjectsLocationsConnectClustersService{s: s}
	rs.Connectors = NewProjectsLocationsConnectClustersConnectorsService(s)
	return rs
}

type ProjectsLocationsConnectClustersService struct {
	s *Service

	Connectors *ProjectsLocationsConnectClustersConnectorsService
}

func NewProjectsLocationsConnectClustersConnectorsService(s *Service) *ProjectsLocationsConnectClustersConnectorsService {
	rs := &ProjectsLocationsConnectClustersConnectorsService{s: s}
	return rs
}

type ProjectsLocationsConnectClustersConnectorsService struct {
	s *Service
}

func NewProjectsLocationsOperationsService(s *Service) *ProjectsLocationsOperationsService {
	rs := &ProjectsLocationsOperationsService{s: s}
	return rs
}

type ProjectsLocationsOperationsService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesService(s *Service) *ProjectsLocationsSchemaRegistriesService {
	rs := &ProjectsLocationsSchemaRegistriesService{s: s}
	rs.Compatibility = NewProjectsLocationsSchemaRegistriesCompatibilityService(s)
	rs.Config = NewProjectsLocationsSchemaRegistriesConfigService(s)
	rs.Contexts = NewProjectsLocationsSchemaRegistriesContextsService(s)
	rs.Mode = NewProjectsLocationsSchemaRegistriesModeService(s)
	rs.Schemas = NewProjectsLocationsSchemaRegistriesSchemasService(s)
	rs.Subjects = NewProjectsLocationsSchemaRegistriesSubjectsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesService struct {
	s *Service

	Compatibility *ProjectsLocationsSchemaRegistriesCompatibilityService

	Config *ProjectsLocationsSchemaRegistriesConfigService

	Contexts *ProjectsLocationsSchemaRegistriesContextsService

	Mode *ProjectsLocationsSchemaRegistriesModeService

	Schemas *ProjectsLocationsSchemaRegistriesSchemasService

	Subjects *ProjectsLocationsSchemaRegistriesSubjectsService
}

func NewProjectsLocationsSchemaRegistriesCompatibilityService(s *Service) *ProjectsLocationsSchemaRegistriesCompatibilityService {
	rs := &ProjectsLocationsSchemaRegistriesCompatibilityService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesCompatibilityService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesConfigService(s *Service) *ProjectsLocationsSchemaRegistriesConfigService {
	rs := &ProjectsLocationsSchemaRegistriesConfigService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesConfigService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsService(s *Service) *ProjectsLocationsSchemaRegistriesContextsService {
	rs := &ProjectsLocationsSchemaRegistriesContextsService{s: s}
	rs.Compatibility = NewProjectsLocationsSchemaRegistriesContextsCompatibilityService(s)
	rs.Config = NewProjectsLocationsSchemaRegistriesContextsConfigService(s)
	rs.Mode = NewProjectsLocationsSchemaRegistriesContextsModeService(s)
	rs.Schemas = NewProjectsLocationsSchemaRegistriesContextsSchemasService(s)
	rs.Subjects = NewProjectsLocationsSchemaRegistriesContextsSubjectsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsService struct {
	s *Service

	Compatibility *ProjectsLocationsSchemaRegistriesContextsCompatibilityService

	Config *ProjectsLocationsSchemaRegistriesContextsConfigService

	Mode *ProjectsLocationsSchemaRegistriesContextsModeService

	Schemas *ProjectsLocationsSchemaRegistriesContextsSchemasService

	Subjects *ProjectsLocationsSchemaRegistriesContextsSubjectsService
}

func NewProjectsLocationsSchemaRegistriesContextsCompatibilityService(s *Service) *ProjectsLocationsSchemaRegistriesContextsCompatibilityService {
	rs := &ProjectsLocationsSchemaRegistriesContextsCompatibilityService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsCompatibilityService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsConfigService(s *Service) *ProjectsLocationsSchemaRegistriesContextsConfigService {
	rs := &ProjectsLocationsSchemaRegistriesContextsConfigService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsConfigService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsModeService(s *Service) *ProjectsLocationsSchemaRegistriesContextsModeService {
	rs := &ProjectsLocationsSchemaRegistriesContextsModeService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsModeService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsSchemasService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSchemasService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSchemasService{s: s}
	rs.Subjects = NewProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService(s)
	rs.Types = NewProjectsLocationsSchemaRegistriesContextsSchemasTypesService(s)
	rs.Versions = NewProjectsLocationsSchemaRegistriesContextsSchemasVersionsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSchemasService struct {
	s *Service

	Subjects *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService

	Types *ProjectsLocationsSchemaRegistriesContextsSchemasTypesService

	Versions *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsService
}

func NewProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsSchemasTypesService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSchemasTypesService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSchemasTypesService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSchemasTypesService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsSchemasVersionsService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSchemasVersionsService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSchemasVersionsService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesContextsSubjectsService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSubjectsService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSubjectsService{s: s}
	rs.Versions = NewProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsService struct {
	s *Service

	Versions *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService
}

func NewProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService{s: s}
	rs.Referencedby = NewProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService struct {
	s *Service

	Referencedby *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService
}

func NewProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService(s *Service) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService {
	rs := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesModeService(s *Service) *ProjectsLocationsSchemaRegistriesModeService {
	rs := &ProjectsLocationsSchemaRegistriesModeService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesModeService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesSchemasService(s *Service) *ProjectsLocationsSchemaRegistriesSchemasService {
	rs := &ProjectsLocationsSchemaRegistriesSchemasService{s: s}
	rs.Subjects = NewProjectsLocationsSchemaRegistriesSchemasSubjectsService(s)
	rs.Types = NewProjectsLocationsSchemaRegistriesSchemasTypesService(s)
	rs.Versions = NewProjectsLocationsSchemaRegistriesSchemasVersionsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesSchemasService struct {
	s *Service

	Subjects *ProjectsLocationsSchemaRegistriesSchemasSubjectsService

	Types *ProjectsLocationsSchemaRegistriesSchemasTypesService

	Versions *ProjectsLocationsSchemaRegistriesSchemasVersionsService
}

func NewProjectsLocationsSchemaRegistriesSchemasSubjectsService(s *Service) *ProjectsLocationsSchemaRegistriesSchemasSubjectsService {
	rs := &ProjectsLocationsSchemaRegistriesSchemasSubjectsService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesSchemasSubjectsService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesSchemasTypesService(s *Service) *ProjectsLocationsSchemaRegistriesSchemasTypesService {
	rs := &ProjectsLocationsSchemaRegistriesSchemasTypesService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesSchemasTypesService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesSchemasVersionsService(s *Service) *ProjectsLocationsSchemaRegistriesSchemasVersionsService {
	rs := &ProjectsLocationsSchemaRegistriesSchemasVersionsService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesSchemasVersionsService struct {
	s *Service
}

func NewProjectsLocationsSchemaRegistriesSubjectsService(s *Service) *ProjectsLocationsSchemaRegistriesSubjectsService {
	rs := &ProjectsLocationsSchemaRegistriesSubjectsService{s: s}
	rs.Versions = NewProjectsLocationsSchemaRegistriesSubjectsVersionsService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesSubjectsService struct {
	s *Service

	Versions *ProjectsLocationsSchemaRegistriesSubjectsVersionsService
}

func NewProjectsLocationsSchemaRegistriesSubjectsVersionsService(s *Service) *ProjectsLocationsSchemaRegistriesSubjectsVersionsService {
	rs := &ProjectsLocationsSchemaRegistriesSubjectsVersionsService{s: s}
	rs.Referencedby = NewProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService(s)
	return rs
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsService struct {
	s *Service

	Referencedby *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService
}

func NewProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService(s *Service) *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService {
	rs := &ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService{s: s}
	return rs
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService struct {
	s *Service
}

// AccessConfig: The configuration of access to the Kafka cluster.
type AccessConfig struct {
	// NetworkConfigs: Required. Virtual Private Cloud (VPC) networks that must be
	// granted direct access to the Kafka cluster. Minimum of 1 network is
	// required. Maximum 10 networks can be specified.
	NetworkConfigs []*NetworkConfig `json:"networkConfigs,omitempty"`
	// ForceSendFields is a list of field names (e.g. "NetworkConfigs") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "NetworkConfigs") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s AccessConfig) MarshalJSON() ([]byte, error) {
	type NoMethod AccessConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Acl: Represents the set of ACLs for a given Kafka Resource Pattern, which
// consists of resource_type, resource_name and pattern_type.
type Acl struct {
	// AclEntries: Required. The ACL entries that apply to the resource pattern.
	// The maximum number of allowed entries 100.
	AclEntries []*AclEntry `json:"aclEntries,omitempty"`
	// Etag: Optional. `etag` is used for concurrency control. An `etag` is
	// returned in the response to `GetAcl` and `CreateAcl`. Callers are required
	// to put that etag in the request to `UpdateAcl` to ensure that their change
	// will be applied to the same version of the acl that exists in the Kafka
	// Cluster. A terminal 'T' character in the etag indicates that the AclEntries
	// were truncated; more entries for the Acl exist on the Kafka Cluster, but
	// can't be returned in the Acl due to repeated field limits.
	Etag string `json:"etag,omitempty"`
	// Name: Identifier. The name for the acl. Represents a single Resource
	// Pattern. Structured like:
	// projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id} The
	// structure of `acl_id` defines the Resource Pattern (resource_type,
	// resource_name, pattern_type) of the acl. `acl_id` is structured like one of
	// the following: For acls on the cluster: `cluster` For acls on a single
	// resource within the cluster: `topic/{resource_name}`
	// `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
	// on all resources that match a prefix: `topicPrefixed/{resource_name}`
	// `consumerGroupPrefixed/{resource_name}`
	// `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
	// given type (i.e. the wildcard literal "*"): `allTopics` (represents
	// `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`)
	// `allTransactionalIds` (represents `transactionalId/*`)
	Name string `json:"name,omitempty"`
	// PatternType: Output only. The ACL pattern type derived from the name. One
	// of: LITERAL, PREFIXED.
	PatternType string `json:"patternType,omitempty"`
	// ResourceName: Output only. The ACL resource name derived from the name. For
	// cluster resource_type, this is always "kafka-cluster". Can be the wildcard
	// literal "*".
	ResourceName string `json:"resourceName,omitempty"`
	// ResourceType: Output only. The ACL resource type derived from the name. One
	// of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.
	ResourceType string `json:"resourceType,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "AclEntries") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "AclEntries") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Acl) MarshalJSON() ([]byte, error) {
	type NoMethod Acl
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// AclEntry: Represents the access granted for a given Resource Pattern in an
// ACL.
type AclEntry struct {
	// Host: Required. The host. Must be set to "*" for Managed Service for Apache
	// Kafka.
	Host string `json:"host,omitempty"`
	// Operation: Required. The operation type. Allowed values are (case
	// insensitive): ALL, READ, WRITE, CREATE, DELETE, ALTER, DESCRIBE,
	// CLUSTER_ACTION, DESCRIBE_CONFIGS, ALTER_CONFIGS, and IDEMPOTENT_WRITE. See
	// https://kafka.apache.org/documentation/#operations_resources_and_protocols
	// for valid combinations of resource_type and operation for different Kafka
	// API requests.
	Operation string `json:"operation,omitempty"`
	// PermissionType: Required. The permission type. Accepted values are (case
	// insensitive): ALLOW, DENY.
	PermissionType string `json:"permissionType,omitempty"`
	// Principal: Required. The principal. Specified as Google Cloud account, with
	// the Kafka StandardAuthorizer prefix "User:". For example:
	// "User:test-kafka-client@test-project.iam.gserviceaccount.com". Can be the
	// wildcard "User:*" to refer to all users.
	Principal string `json:"principal,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Host") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Host") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s AclEntry) MarshalJSON() ([]byte, error) {
	type NoMethod AclEntry
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// AddAclEntryResponse: Response for AddAclEntry.
type AddAclEntryResponse struct {
	// Acl: The updated acl.
	Acl *Acl `json:"acl,omitempty"`
	// AclCreated: Whether the acl was created as a result of adding the acl entry.
	AclCreated bool `json:"aclCreated,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Acl") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Acl") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s AddAclEntryResponse) MarshalJSON() ([]byte, error) {
	type NoMethod AddAclEntryResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CancelOperationRequest: The request message for Operations.CancelOperation.
type CancelOperationRequest struct {
}

// CapacityConfig: A capacity configuration of a Kafka cluster.
type CapacityConfig struct {
	// MemoryBytes: Required. The memory to provision for the cluster in bytes. The
	// CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472
	// (3 GiB).
	MemoryBytes int64 `json:"memoryBytes,omitempty,string"`
	// VcpuCount: Required. The number of vCPUs to provision for the cluster.
	// Minimum: 3.
	VcpuCount int64 `json:"vcpuCount,omitempty,string"`
	// ForceSendFields is a list of field names (e.g. "MemoryBytes") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "MemoryBytes") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CapacityConfig) MarshalJSON() ([]byte, error) {
	type NoMethod CapacityConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CheckCompatibilityRequest: Request for CheckCompatibility.
type CheckCompatibilityRequest struct {
	// References: Optional. The schema references used by the schema.
	References []*SchemaReference `json:"references,omitempty"`
	// Schema: Required. The schema payload
	Schema string `json:"schema,omitempty"`
	// SchemaType: Optional. The schema type of the schema.
	//
	// Possible values:
	//   "SCHEMA_TYPE_UNSPECIFIED" - No schema type. The default will be AVRO.
	//   "AVRO" - Avro schema type.
	//   "JSON" - JSON schema type.
	//   "PROTOBUF" - Protobuf schema type.
	SchemaType string `json:"schemaType,omitempty"`
	// Verbose: Optional. If true, the response will contain the compatibility
	// check result with reasons for failed checks. The default is false.
	Verbose bool `json:"verbose,omitempty"`
	// ForceSendFields is a list of field names (e.g. "References") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "References") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CheckCompatibilityRequest) MarshalJSON() ([]byte, error) {
	type NoMethod CheckCompatibilityRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CheckCompatibilityResponse: Response for CheckCompatibility.
type CheckCompatibilityResponse struct {
	// IsCompatible: The compatibility check result. If true, the schema is
	// compatible with the resource.
	IsCompatible bool `json:"is_compatible,omitempty"`
	// Messages: Failure reasons if verbose = true.
	Messages []string `json:"messages,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "IsCompatible") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "IsCompatible") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CheckCompatibilityResponse) MarshalJSON() ([]byte, error) {
	type NoMethod CheckCompatibilityResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Cluster: An Apache Kafka cluster deployed in a location.
type Cluster struct {
	// CapacityConfig: Required. Capacity configuration for the Kafka cluster.
	CapacityConfig *CapacityConfig `json:"capacityConfig,omitempty"`
	// CreateTime: Output only. The time when the cluster was created.
	CreateTime string `json:"createTime,omitempty"`
	// GcpConfig: Required. Configuration properties for a Kafka cluster deployed
	// to Google Cloud Platform.
	GcpConfig *GcpConfig `json:"gcpConfig,omitempty"`
	// Labels: Optional. Labels as key value pairs.
	Labels map[string]string `json:"labels,omitempty"`
	// Name: Identifier. The name of the cluster. Structured like:
	// projects/{project_number}/locations/{location}/clusters/{cluster_id}
	Name string `json:"name,omitempty"`
	// RebalanceConfig: Optional. Rebalance configuration for the Kafka cluster.
	RebalanceConfig *RebalanceConfig `json:"rebalanceConfig,omitempty"`
	// SatisfiesPzi: Output only. Reserved for future use.
	SatisfiesPzi bool `json:"satisfiesPzi,omitempty"`
	// SatisfiesPzs: Output only. Reserved for future use.
	SatisfiesPzs bool `json:"satisfiesPzs,omitempty"`
	// State: Output only. The current state of the cluster.
	//
	// Possible values:
	//   "STATE_UNSPECIFIED" - A state was not specified.
	//   "CREATING" - The cluster is being created.
	//   "ACTIVE" - The cluster is active.
	//   "DELETING" - The cluster is being deleted.
	State string `json:"state,omitempty"`
	// UpdateTime: Output only. The time when the cluster was last updated.
	UpdateTime string `json:"updateTime,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "CapacityConfig") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "CapacityConfig") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Cluster) MarshalJSON() ([]byte, error) {
	type NoMethod Cluster
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConnectAccessConfig: The configuration of access to the Kafka Connect
// cluster.
type ConnectAccessConfig struct {
	// NetworkConfigs: Required. Virtual Private Cloud (VPC) networks that must be
	// granted direct access to the Kafka Connect cluster. Minimum of 1 network is
	// required. Maximum 10 networks can be specified.
	NetworkConfigs []*ConnectNetworkConfig `json:"networkConfigs,omitempty"`
	// ForceSendFields is a list of field names (e.g. "NetworkConfigs") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "NetworkConfigs") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConnectAccessConfig) MarshalJSON() ([]byte, error) {
	type NoMethod ConnectAccessConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConnectCluster: An Apache Kafka Connect cluster deployed in a location.
type ConnectCluster struct {
	// CapacityConfig: Required. Capacity configuration for the Kafka Connect
	// cluster.
	CapacityConfig *CapacityConfig `json:"capacityConfig,omitempty"`
	// Config: Optional. Configurations for the worker that are overridden from the
	// defaults. The key of the map is a Kafka Connect worker property name, for
	// example: `exactly.once.source.support`.
	Config map[string]string `json:"config,omitempty"`
	// CreateTime: Output only. The time when the cluster was created.
	CreateTime string `json:"createTime,omitempty"`
	// GcpConfig: Required. Configuration properties for a Kafka Connect cluster
	// deployed to Google Cloud Platform.
	GcpConfig *ConnectGcpConfig `json:"gcpConfig,omitempty"`
	// KafkaCluster: Required. Immutable. The name of the Kafka cluster this Kafka
	// Connect cluster is attached to. Structured like:
	// projects/{project}/locations/{location}/clusters/{cluster}
	KafkaCluster string `json:"kafkaCluster,omitempty"`
	// Labels: Optional. Labels as key value pairs.
	Labels map[string]string `json:"labels,omitempty"`
	// Name: Identifier. The name of the Kafka Connect cluster. Structured like:
	// projects/{project_number}/locations/{location}/connectClusters/{connect_clust
	// er_id}
	Name string `json:"name,omitempty"`
	// State: Output only. The current state of the cluster.
	//
	// Possible values:
	//   "STATE_UNSPECIFIED" - A state was not specified.
	//   "CREATING" - The cluster is being created.
	//   "ACTIVE" - The cluster is active.
	//   "DELETING" - The cluster is being deleted.
	State string `json:"state,omitempty"`
	// UpdateTime: Output only. The time when the cluster was last updated.
	UpdateTime string `json:"updateTime,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "CapacityConfig") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "CapacityConfig") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConnectCluster) MarshalJSON() ([]byte, error) {
	type NoMethod ConnectCluster
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConnectGcpConfig: Configuration properties for a Kafka Connect cluster
// deployed to Google Cloud Platform.
type ConnectGcpConfig struct {
	// AccessConfig: Required. Access configuration for the Kafka Connect cluster.
	AccessConfig *ConnectAccessConfig `json:"accessConfig,omitempty"`
	// SecretPaths: Optional. Secrets to load into workers. Exact SecretVersions
	// from Secret Manager must be provided -- aliases are not supported. Up to 32
	// secrets may be loaded into one cluster. Format: projects//secrets//versions/
	SecretPaths []string `json:"secretPaths,omitempty"`
	// ForceSendFields is a list of field names (e.g. "AccessConfig") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "AccessConfig") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConnectGcpConfig) MarshalJSON() ([]byte, error) {
	type NoMethod ConnectGcpConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConnectNetworkConfig: The configuration of a Virtual Private Cloud (VPC)
// network that can access the Kafka Connect cluster.
type ConnectNetworkConfig struct {
	// AdditionalSubnets: Optional. Additional subnets may be specified. They may
	// be in another region, but must be in the same VPC network. The Connect
	// workers can communicate with network endpoints in either the primary or
	// additional subnets.
	AdditionalSubnets []string `json:"additionalSubnets,omitempty"`
	// DnsDomainNames: Optional. Additional DNS domain names from the subnet's
	// network to be made visible to the Connect Cluster. When using MirrorMaker2,
	// it's necessary to add the bootstrap address's dns domain name of the target
	// cluster to make it visible to the connector. For example:
	// my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
	DnsDomainNames []string `json:"dnsDomainNames,omitempty"`
	// PrimarySubnet: Required. VPC subnet to make available to the Kafka Connect
	// cluster. Structured like:
	// projects/{project}/regions/{region}/subnetworks/{subnet_id} It is used to
	// create a Private Service Connect (PSC) interface for the Kafka Connect
	// workers. It must be located in the same region as the Kafka Connect cluster.
	// The CIDR range of the subnet must be within the IPv4 address ranges for
	// private networks, as specified in RFC 1918. The primary subnet CIDR range
	// must have a minimum size of /22 (1024 addresses).
	PrimarySubnet string `json:"primarySubnet,omitempty"`
	// ForceSendFields is a list of field names (e.g. "AdditionalSubnets") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "AdditionalSubnets") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConnectNetworkConfig) MarshalJSON() ([]byte, error) {
	type NoMethod ConnectNetworkConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Connector: A Kafka Connect connector in a given ConnectCluster.
type Connector struct {
	// Configs: Optional. Connector config as keys/values. The keys of the map are
	// connector property names, for example: `connector.class`, `tasks.max`,
	// `key.converter`.
	Configs map[string]string `json:"configs,omitempty"`
	// Name: Identifier. The name of the connector. Structured like:
	// projects/{project}/locations/{location}/connectClusters/{connect_cluster}/con
	// nectors/{connector}
	Name string `json:"name,omitempty"`
	// State: Output only. The current state of the connector.
	//
	// Possible values:
	//   "STATE_UNSPECIFIED" - A state was not specified.
	//   "UNASSIGNED" - The connector is not assigned to any tasks, usually
	// transient.
	//   "RUNNING" - The connector is running.
	//   "PAUSED" - The connector has been paused.
	//   "FAILED" - The connector has failed. See logs for why.
	//   "RESTARTING" - The connector is restarting.
	//   "STOPPED" - The connector has been stopped.
	State string `json:"state,omitempty"`
	// TaskRestartPolicy: Optional. Restarts the individual tasks of a Connector.
	TaskRestartPolicy *TaskRetryPolicy `json:"taskRestartPolicy,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Configs") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Configs") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Connector) MarshalJSON() ([]byte, error) {
	type NoMethod Connector
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConsumerGroup: A Kafka consumer group in a given cluster.
type ConsumerGroup struct {
	// Name: Identifier. The name of the consumer group. The `consumer_group`
	// segment is used when connecting directly to the cluster. Structured like:
	// projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{co
	// nsumer_group}
	Name string `json:"name,omitempty"`
	// Topics: Optional. Metadata for this consumer group for all topics it has
	// metadata for. The key of the map is a topic name, structured like:
	// projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
	Topics map[string]ConsumerTopicMetadata `json:"topics,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Name") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Name") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConsumerGroup) MarshalJSON() ([]byte, error) {
	type NoMethod ConsumerGroup
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConsumerPartitionMetadata: Metadata for a consumer group corresponding to a
// specific partition.
type ConsumerPartitionMetadata struct {
	// Metadata: Optional. The associated metadata for this partition, or empty if
	// it does not exist.
	Metadata string `json:"metadata,omitempty"`
	// Offset: Required. The current offset for this partition, or 0 if no offset
	// has been committed.
	Offset int64 `json:"offset,omitempty,string"`
	// ForceSendFields is a list of field names (e.g. "Metadata") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Metadata") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConsumerPartitionMetadata) MarshalJSON() ([]byte, error) {
	type NoMethod ConsumerPartitionMetadata
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ConsumerTopicMetadata: Metadata for a consumer group corresponding to a
// specific topic.
type ConsumerTopicMetadata struct {
	// Partitions: Optional. Metadata for this consumer group and topic for all
	// partition indexes it has metadata for.
	Partitions map[string]ConsumerPartitionMetadata `json:"partitions,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Partitions") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Partitions") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ConsumerTopicMetadata) MarshalJSON() ([]byte, error) {
	type NoMethod ConsumerTopicMetadata
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Context: Context represents an independent schema grouping in a schema
// registry instance.
type Context struct {
	// Name: Identifier. The name of the context. Structured like:
	// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/c
	// ontexts/{context}` The context name {context} can contain the following: *
	// Up to 255 characters. * Allowed characters: letters (uppercase or
	// lowercase), numbers, and the following special characters: `.`, `-`, `_`,
	// `+`, `%`, and `~`.
	Name string `json:"name,omitempty"`
	// Subjects: Optional. The subjects of the context.
	Subjects []string `json:"subjects,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Name") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Name") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Context) MarshalJSON() ([]byte, error) {
	type NoMethod Context
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CreateSchemaRegistryRequest: Request to create a schema registry instance.
type CreateSchemaRegistryRequest struct {
	// SchemaRegistry: Required. The schema registry instance to create. The name
	// field is ignored.
	SchemaRegistry *SchemaRegistry `json:"schemaRegistry,omitempty"`
	// SchemaRegistryId: Required. The schema registry instance ID to use for this
	// schema registry. The ID must contain only letters (a-z, A-Z), numbers (0-9),
	// and underscores (-). The maximum length is 63 characters. The ID must not
	// start with a number.
	SchemaRegistryId string `json:"schemaRegistryId,omitempty"`
	// ForceSendFields is a list of field names (e.g. "SchemaRegistry") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "SchemaRegistry") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CreateSchemaRegistryRequest) MarshalJSON() ([]byte, error) {
	type NoMethod CreateSchemaRegistryRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CreateVersionRequest: Request for CreateVersion.
type CreateVersionRequest struct {
	// Id: Optional. The schema ID of the schema. If not specified, the schema ID
	// will be generated by the server. If the schema ID is specified, it must not
	// be used by an existing schema that is different from the schema to be
	// created.
	Id int64 `json:"id,omitempty"`
	// Normalize: Optional. If true, the schema will be normalized before being
	// stored. The default is false.
	Normalize bool `json:"normalize,omitempty"`
	// References: Optional. The schema references used by the schema.
	References []*SchemaReference `json:"references,omitempty"`
	// Schema: Required. The schema payload
	Schema string `json:"schema,omitempty"`
	// SchemaType: Optional. The type of the schema. It is optional. If not
	// specified, the schema type will be AVRO.
	//
	// Possible values:
	//   "SCHEMA_TYPE_UNSPECIFIED" - No schema type. The default will be AVRO.
	//   "AVRO" - Avro schema type.
	//   "JSON" - JSON schema type.
	//   "PROTOBUF" - Protobuf schema type.
	SchemaType string `json:"schemaType,omitempty"`
	// Version: Optional. The version to create. It is optional. If not specified,
	// the version will be created with the max version ID of the subject increased
	// by 1. If the version ID is specified, it will be used as the new version ID
	// and must not be used by an existing version of the subject.
	Version int64 `json:"version,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Id") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Id") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CreateVersionRequest) MarshalJSON() ([]byte, error) {
	type NoMethod CreateVersionRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// CreateVersionResponse: Response for CreateVersion.
type CreateVersionResponse struct {
	// Id: The unique identifier of the schema created.
	Id int64 `json:"id,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Id") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Id") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s CreateVersionResponse) MarshalJSON() ([]byte, error) {
	type NoMethod CreateVersionResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Empty: A generic empty message that you can re-use to avoid defining
// duplicated empty messages in your APIs. A typical example is to use it as
// the request or the response type of an API method. For instance: service Foo
// { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type Empty struct {
	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
}

// GcpConfig: Configuration properties for a Kafka cluster deployed to Google
// Cloud Platform.
type GcpConfig struct {
	// AccessConfig: Required. Access configuration for the Kafka cluster.
	AccessConfig *AccessConfig `json:"accessConfig,omitempty"`
	// KmsKey: Optional. Immutable. The Cloud KMS Key name to use for encryption.
	// The key must be located in the same region as the cluster and cannot be
	// changed. Structured like:
	// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypt
	// o_key}.
	KmsKey string `json:"kmsKey,omitempty"`
	// ForceSendFields is a list of field names (e.g. "AccessConfig") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "AccessConfig") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s GcpConfig) MarshalJSON() ([]byte, error) {
	type NoMethod GcpConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// HttpBody: Message that represents an arbitrary HTTP body. It should only be
// used for payload formats that can't be represented as JSON, such as raw
// binary or an HTML page. This message can be used both in streaming and
// non-streaming API methods in the request as well as the response. It can be
// used as a top-level request field, which is convenient if one wants to
// extract parameters from either the URL or HTTP template into the request
// fields and also want access to the raw HTTP body. Example: message
// GetResourceRequest { // A unique request id. string request_id = 1; // The
// raw HTTP body is bound to this field. google.api.HttpBody http_body = 2; }
// service ResourceService { rpc GetResource(GetResourceRequest) returns
// (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns
// (google.protobuf.Empty); } Example with streaming methods: service
// CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream
// google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
// (stream google.api.HttpBody); } Use of this type only changes how the
// request and response bodies are handled, all other features will continue to
// work unchanged.
type HttpBody struct {
	// ContentType: The HTTP Content-Type header value specifying the content type
	// of the body.
	ContentType string `json:"contentType,omitempty"`
	// Data: The HTTP request/response body as raw binary.
	Data string `json:"data,omitempty"`
	// Extensions: Application specific response metadata. Must be set in the first
	// response for streaming APIs.
	Extensions []googleapi.RawMessage `json:"extensions,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "ContentType") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "ContentType") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s HttpBody) MarshalJSON() ([]byte, error) {
	type NoMethod HttpBody
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListAclsResponse: Response for ListAcls.
type ListAclsResponse struct {
	// Acls: The list of acls in the requested parent. The order of the acls is
	// unspecified.
	Acls []*Acl `json:"acls,omitempty"`
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Acls") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Acls") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListAclsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListAclsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListClustersResponse: Response for ListClusters.
type ListClustersResponse struct {
	// Clusters: The list of Clusters in the requested parent.
	Clusters []*Cluster `json:"clusters,omitempty"`
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`
	// Unreachable: Locations that could not be reached.
	Unreachable []string `json:"unreachable,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Clusters") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Clusters") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListClustersResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListClustersResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListConnectClustersResponse: Response for ListConnectClusters.
type ListConnectClustersResponse struct {
	// ConnectClusters: The list of Connect clusters in the requested parent.
	ConnectClusters []*ConnectCluster `json:"connectClusters,omitempty"`
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`
	// Unreachable: Locations that could not be reached.
	Unreachable []string `json:"unreachable,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "ConnectClusters") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "ConnectClusters") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListConnectClustersResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListConnectClustersResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListConnectorsResponse: Response for ListConnectors.
type ListConnectorsResponse struct {
	// Connectors: The list of connectors in the requested parent.
	Connectors []*Connector `json:"connectors,omitempty"`
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Connectors") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Connectors") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListConnectorsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListConnectorsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListConsumerGroupsResponse: Response for ListConsumerGroups.
type ListConsumerGroupsResponse struct {
	// ConsumerGroups: The list of consumer group in the requested parent. The
	// order of the consumer groups is unspecified.
	ConsumerGroups []*ConsumerGroup `json:"consumerGroups,omitempty"`
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "ConsumerGroups") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "ConsumerGroups") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListConsumerGroupsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListConsumerGroupsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListLocationsResponse: The response message for Locations.ListLocations.
type ListLocationsResponse struct {
	// Locations: A list of locations that matches the specified filter in the
	// request.
	Locations []*Location `json:"locations,omitempty"`
	// NextPageToken: The standard List next-page token.
	NextPageToken string `json:"nextPageToken,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Locations") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Locations") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListLocationsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListLocationsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListOperationsResponse: The response message for Operations.ListOperations.
type ListOperationsResponse struct {
	// NextPageToken: The standard List next-page token.
	NextPageToken string `json:"nextPageToken,omitempty"`
	// Operations: A list of operations that matches the specified filter in the
	// request.
	Operations []*Operation `json:"operations,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "NextPageToken") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "NextPageToken") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListOperationsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListOperationsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListSchemaRegistriesResponse: Request for ListSchemaRegistries.
type ListSchemaRegistriesResponse struct {
	// SchemaRegistries: The schema registry instances.
	SchemaRegistries []*SchemaRegistry `json:"schemaRegistries,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "SchemaRegistries") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "SchemaRegistries") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListSchemaRegistriesResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListSchemaRegistriesResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// ListTopicsResponse: Response for ListTopics.
type ListTopicsResponse struct {
	// NextPageToken: A token that can be sent as `page_token` to retrieve the next
	// page of results. If this field is omitted, there are no more results.
	NextPageToken string `json:"nextPageToken,omitempty"`
	// Topics: The list of topics in the requested parent. The order of the topics
	// is unspecified.
	Topics []*Topic `json:"topics,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "NextPageToken") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "NextPageToken") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s ListTopicsResponse) MarshalJSON() ([]byte, error) {
	type NoMethod ListTopicsResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Location: A resource that represents a Google Cloud location.
type Location struct {
	// DisplayName: The friendly name for this location, typically a nearby city
	// name. For example, "Tokyo".
	DisplayName string `json:"displayName,omitempty"`
	// Labels: Cross-service attributes for the location. For example
	// {"cloud.googleapis.com/region": "us-east1"}
	Labels map[string]string `json:"labels,omitempty"`
	// LocationId: The canonical id for this location. For example: "us-east1".
	LocationId string `json:"locationId,omitempty"`
	// Metadata: Service-specific metadata. For example the available capacity at
	// the given location.
	Metadata googleapi.RawMessage `json:"metadata,omitempty"`
	// Name: Resource name for the location, which may vary between
	// implementations. For example:
	// "projects/example-project/locations/us-east1"
	Name string `json:"name,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "DisplayName") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "DisplayName") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Location) MarshalJSON() ([]byte, error) {
	type NoMethod Location
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// LookupVersionRequest: Request for LookupVersion.
type LookupVersionRequest struct {
	// Deleted: Optional. If true, soft-deleted versions will be included in
	// lookup, no matter if the subject is active or soft-deleted. If false,
	// soft-deleted versions will be excluded. The default is false.
	Deleted bool `json:"deleted,omitempty"`
	// Normalize: Optional. If true, the schema will be normalized before being
	// looked up. The default is false.
	Normalize bool `json:"normalize,omitempty"`
	// References: Optional. The schema references used by the schema.
	References []*SchemaReference `json:"references,omitempty"`
	// Schema: Required. The schema payload
	Schema string `json:"schema,omitempty"`
	// SchemaType: Optional. The schema type of the schema.
	//
	// Possible values:
	//   "SCHEMA_TYPE_UNSPECIFIED" - No schema type. The default will be AVRO.
	//   "AVRO" - Avro schema type.
	//   "JSON" - JSON schema type.
	//   "PROTOBUF" - Protobuf schema type.
	SchemaType string `json:"schemaType,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Deleted") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Deleted") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s LookupVersionRequest) MarshalJSON() ([]byte, error) {
	type NoMethod LookupVersionRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// NetworkConfig: The configuration of a Virtual Private Cloud (VPC) network
// that can access the Kafka cluster.
type NetworkConfig struct {
	// Subnet: Required. Name of the VPC subnet in which to create Private Service
	// Connect (PSC) endpoints for the Kafka brokers and bootstrap address.
	// Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}
	// The subnet must be located in the same region as the Kafka cluster. The
	// project may differ. Multiple subnets from the same parent network must not
	// be specified.
	Subnet string `json:"subnet,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Subnet") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Subnet") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s NetworkConfig) MarshalJSON() ([]byte, error) {
	type NoMethod NetworkConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Operation: This resource represents a long-running operation that is the
// result of a network API call.
type Operation struct {
	// Done: If the value is `false`, it means the operation is still in progress.
	// If `true`, the operation is completed, and either `error` or `response` is
	// available.
	Done bool `json:"done,omitempty"`
	// Error: The error result of the operation in case of failure or cancellation.
	Error *Status `json:"error,omitempty"`
	// Metadata: Service-specific metadata associated with the operation. It
	// typically contains progress information and common metadata such as create
	// time. Some services might not provide such metadata. Any method that returns
	// a long-running operation should document the metadata type, if any.
	Metadata googleapi.RawMessage `json:"metadata,omitempty"`
	// Name: The server-assigned name, which is only unique within the same service
	// that originally returns it. If you use the default HTTP mapping, the `name`
	// should be a resource name ending with `operations/{unique_id}`.
	Name string `json:"name,omitempty"`
	// Response: The normal, successful response of the operation. If the original
	// method returns no data on success, such as `Delete`, the response is
	// `google.protobuf.Empty`. If the original method is standard
	// `Get`/`Create`/`Update`, the response should be the resource. For other
	// methods, the response should have the type `XxxResponse`, where `Xxx` is the
	// original method name. For example, if the original method name is
	// `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
	Response googleapi.RawMessage `json:"response,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Done") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Done") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Operation) MarshalJSON() ([]byte, error) {
	type NoMethod Operation
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// OperationMetadata: Represents the metadata of the long-running operation.
type OperationMetadata struct {
	// ApiVersion: Output only. API version used to start the operation.
	ApiVersion string `json:"apiVersion,omitempty"`
	// CreateTime: Output only. The time the operation was created.
	CreateTime string `json:"createTime,omitempty"`
	// EndTime: Output only. The time the operation finished running.
	EndTime string `json:"endTime,omitempty"`
	// RequestedCancellation: Output only. Identifies whether the user has
	// requested cancellation of the operation. Operations that have been cancelled
	// successfully have Operation.error value with a google.rpc.Status.code of 1,
	// corresponding to `Code.CANCELLED`.
	RequestedCancellation bool `json:"requestedCancellation,omitempty"`
	// StatusMessage: Output only. Human-readable status of the operation, if any.
	StatusMessage string `json:"statusMessage,omitempty"`
	// Target: Output only. Server-defined resource path for the target of the
	// operation.
	Target string `json:"target,omitempty"`
	// Verb: Output only. Name of the verb executed by the operation.
	Verb string `json:"verb,omitempty"`
	// ForceSendFields is a list of field names (e.g. "ApiVersion") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "ApiVersion") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s OperationMetadata) MarshalJSON() ([]byte, error) {
	type NoMethod OperationMetadata
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// PauseConnectorRequest: Request for PauseConnector.
type PauseConnectorRequest struct {
}

// PauseConnectorResponse: Response for PauseConnector.
type PauseConnectorResponse struct {
	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
}

// RebalanceConfig: Defines rebalancing behavior of a Kafka cluster.
type RebalanceConfig struct {
	// Mode: Optional. The rebalance behavior for the cluster. When not specified,
	// defaults to `NO_REBALANCE`.
	//
	// Possible values:
	//   "MODE_UNSPECIFIED" - A mode was not specified. Do not use.
	//   "NO_REBALANCE" - Do not rebalance automatically.
	//   "AUTO_REBALANCE_ON_SCALE_UP" - Automatically rebalance topic partitions
	// among brokers when the cluster is scaled up.
	Mode string `json:"mode,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Mode") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Mode") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s RebalanceConfig) MarshalJSON() ([]byte, error) {
	type NoMethod RebalanceConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// RemoveAclEntryResponse: Response for RemoveAclEntry.
type RemoveAclEntryResponse struct {
	// Acl: The updated acl. Returned if the removed acl entry was not the last
	// entry in the acl.
	Acl *Acl `json:"acl,omitempty"`
	// AclDeleted: Returned with value true if the removed acl entry was the last
	// entry in the acl, resulting in acl deletion.
	AclDeleted bool `json:"aclDeleted,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Acl") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Acl") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s RemoveAclEntryResponse) MarshalJSON() ([]byte, error) {
	type NoMethod RemoveAclEntryResponse
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// RestartConnectorRequest: Request for RestartConnector.
type RestartConnectorRequest struct {
}

// RestartConnectorResponse: Response for RestartConnector.
type RestartConnectorResponse struct {
	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
}

// ResumeConnectorRequest: Request for ResumeConnector.
type ResumeConnectorRequest struct {
}

// ResumeConnectorResponse: Response for ResumeConnector.
type ResumeConnectorResponse struct {
	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
}

// Schema: Schema for a Kafka message.
type Schema struct {
	// References: Optional. The schema references used by the schema.
	References []*SchemaReference `json:"references,omitempty"`
	// Schema: The schema payload.
	Schema string `json:"schema,omitempty"`
	// SchemaType: Optional. The schema type of the schema.
	//
	// Possible values:
	//   "SCHEMA_TYPE_UNSPECIFIED" - No schema type. The default will be AVRO.
	//   "AVRO" - Avro schema type.
	//   "JSON" - JSON schema type.
	//   "PROTOBUF" - Protobuf schema type.
	SchemaType string `json:"schemaType,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "References") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "References") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Schema) MarshalJSON() ([]byte, error) {
	type NoMethod Schema
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// SchemaConfig: SchemaConfig represents configuration for a schema registry or
// a specific subject.
type SchemaConfig struct {
	// Alias: Optional. The subject to which this subject is an alias of. Only
	// applicable for subject config.
	Alias string `json:"alias,omitempty"`
	// Compatibility: Required. The compatibility type of the schema. The default
	// value is BACKWARD. If unset in a SchemaSubject-level SchemaConfig, defaults
	// to the global value. If unset in a SchemaRegistry-level SchemaConfig,
	// reverts to the default value.
	//
	// Possible values:
	//   "NONE" - No compatibility check.
	//   "BACKWARD" - Backwards compatible with the most recent version.
	//   "BACKWARD_TRANSITIVE" - Backwards compatible with all previous versions.
	//   "FORWARD" - Forwards compatible with the most recent version.
	//   "FORWARD_TRANSITIVE" - Forwards compatible with all previous versions.
	//   "FULL" - Backwards and forwards compatible with the most recent version.
	//   "FULL_TRANSITIVE" - Backwards and forwards compatible with all previous
	// versions.
	Compatibility string `json:"compatibility,omitempty"`
	// Normalize: Optional. If true, the schema will be normalized before being
	// stored or looked up. The default is false. If unset in a SchemaSubject-level
	// SchemaConfig, the global value will be used. If unset in a
	// SchemaRegistry-level SchemaConfig, reverts to the default value.
	Normalize bool `json:"normalize,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Alias") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Alias") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s SchemaConfig) MarshalJSON() ([]byte, error) {
	type NoMethod SchemaConfig
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// SchemaMode: SchemaMode represents the mode of a schema registry or a
// specific subject. Four modes are supported: * NONE: This is the default mode
// for a subject and essentially means that the subject does not have any mode
// set. This means the subject will follow the schema registry's mode. *
// READONLY: The schema registry is in read-only mode. * READWRITE: The schema
// registry is in read-write mode, which allows limited write operations on the
// schema. * IMPORT: The schema registry is in import mode, which allows more
// editing operations on the schema for data importing purposes.
type SchemaMode struct {
	// Mode: Required. The mode type of a schema registry (READWRITE by default) or
	// of a subject (NONE by default, which means use the global schema registry
	// setting).
	//
	// Possible values:
	//   "NONE" - No mode.
	//   "READONLY" - READONLY mode.
	//   "READWRITE" - READWRITE mode.
	//   "IMPORT" - IMPORT mode.
	Mode string `json:"mode,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Mode") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Mode") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s SchemaMode) MarshalJSON() ([]byte, error) {
	type NoMethod SchemaMode
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// SchemaReference: SchemaReference is a reference to a schema.
type SchemaReference struct {
	// Name: Required. The name of the reference.
	Name string `json:"name,omitempty"`
	// Subject: Required. The subject of the reference.
	Subject string `json:"subject,omitempty"`
	// Version: Required. The version of the reference.
	Version int64 `json:"version,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Name") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Name") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s SchemaReference) MarshalJSON() ([]byte, error) {
	type NoMethod SchemaReference
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// SchemaRegistry: SchemaRegistry is a schema registry instance.
type SchemaRegistry struct {
	// Contexts: Output only. The contexts of the schema registry instance.
	Contexts []string `json:"contexts,omitempty"`
	// Name: Identifier. The name of the schema registry instance. Structured like:
	// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
	// The instance name {schema_registry} can contain the following: * Up to 255
	// characters. * Letters (uppercase or lowercase), numbers, and underscores.
	Name string `json:"name,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Contexts") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Contexts") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s SchemaRegistry) MarshalJSON() ([]byte, error) {
	type NoMethod SchemaRegistry
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// SchemaVersion: Version of a schema.
type SchemaVersion struct {
	// Id: Required. The schema ID.
	Id int64 `json:"id,omitempty"`
	// References: Optional. The schema references used by the schema.
	References []*SchemaReference `json:"references,omitempty"`
	// Schema: Required. The schema payload.
	Schema string `json:"schema,omitempty"`
	// SchemaType: Optional. The schema type of the schema.
	//
	// Possible values:
	//   "SCHEMA_TYPE_UNSPECIFIED" - No schema type. The default will be AVRO.
	//   "AVRO" - Avro schema type.
	//   "JSON" - JSON schema type.
	//   "PROTOBUF" - Protobuf schema type.
	SchemaType string `json:"schemaType,omitempty"`
	// Subject: Required. The subject of the version.
	Subject string `json:"subject,omitempty"`
	// Version: Required. The version ID
	Version int64 `json:"version,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Id") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Id") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s SchemaVersion) MarshalJSON() ([]byte, error) {
	type NoMethod SchemaVersion
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Status: The `Status` type defines a logical error model that is suitable for
// different programming environments, including REST APIs and RPC APIs. It is
// used by gRPC (https://github.com/grpc). Each `Status` message contains three
// pieces of data: error code, error message, and error details. You can find
// out more about this error model and how to work with it in the API Design
// Guide (https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code: The status code, which should be an enum value of google.rpc.Code.
	Code int64 `json:"code,omitempty"`
	// Details: A list of messages that carry the error details. There is a common
	// set of message types for APIs to use.
	Details []googleapi.RawMessage `json:"details,omitempty"`
	// Message: A developer-facing error message, which should be in English. Any
	// user-facing error message should be localized and sent in the
	// google.rpc.Status.details field, or localized by the client.
	Message string `json:"message,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Code") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Code") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Status) MarshalJSON() ([]byte, error) {
	type NoMethod Status
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// StopConnectorRequest: Request for StopConnector.
type StopConnectorRequest struct {
}

// StopConnectorResponse: Response for StopConnector.
type StopConnectorResponse struct {
	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
}

// TaskRetryPolicy: Task Retry Policy is implemented on a best-effort basis.
// Retry delay will be exponential based on provided minimum and maximum
// backoffs. https://en.wikipedia.org/wiki/Exponential_backoff. Note that the
// delay between consecutive task restarts may not always precisely match the
// configured settings. This can happen when the ConnectCluster is in
// rebalancing state or if the ConnectCluster is unresponsive etc. The default
// values for minimum and maximum backoffs are 60 seconds and 30 minutes
// respectively.
type TaskRetryPolicy struct {
	// MaximumBackoff: Optional. The maximum amount of time to wait before retrying
	// a failed task. This sets an upper bound for the backoff delay.
	MaximumBackoff string `json:"maximumBackoff,omitempty"`
	// MinimumBackoff: Optional. The minimum amount of time to wait before retrying
	// a failed task. This sets a lower bound for the backoff delay.
	MinimumBackoff string `json:"minimumBackoff,omitempty"`
	// ForceSendFields is a list of field names (e.g. "MaximumBackoff") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "MaximumBackoff") to include in
	// API requests with the JSON null value. By default, fields with empty values
	// are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s TaskRetryPolicy) MarshalJSON() ([]byte, error) {
	type NoMethod TaskRetryPolicy
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// Topic: A Kafka topic in a given cluster.
type Topic struct {
	// Configs: Optional. Configurations for the topic that are overridden from the
	// cluster defaults. The key of the map is a Kafka topic property name, for
	// example: `cleanup.policy`, `compression.type`.
	Configs map[string]string `json:"configs,omitempty"`
	// Name: Identifier. The name of the topic. The `topic` segment is used when
	// connecting directly to the cluster. Structured like:
	// projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
	Name string `json:"name,omitempty"`
	// PartitionCount: Required. The number of partitions this topic has. The
	// partition count can only be increased, not decreased. Please note that if
	// partitions are increased for a topic that has a key, the partitioning logic
	// or the ordering of the messages will be affected.
	PartitionCount int64 `json:"partitionCount,omitempty"`
	// ReplicationFactor: Required. Immutable. The number of replicas of each
	// partition. A replication factor of 3 is recommended for high availability.
	ReplicationFactor int64 `json:"replicationFactor,omitempty"`

	// ServerResponse contains the HTTP response code and headers from the server.
	googleapi.ServerResponse `json:"-"`
	// ForceSendFields is a list of field names (e.g. "Configs") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Configs") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s Topic) MarshalJSON() ([]byte, error) {
	type NoMethod Topic
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// UpdateSchemaConfigRequest: Request for updating schema config. On a
// SchemaSubject-level SchemaConfig, an unset field will be removed from the
// SchemaConfig.
type UpdateSchemaConfigRequest struct {
	// Compatibility: Required. The compatibility type of the schemas. Cannot be
	// unset for a SchemaRegistry-level SchemaConfig. If unset on a
	// SchemaSubject-level SchemaConfig, removes the compatibility field for the
	// SchemaConfig.
	//
	// Possible values:
	//   "NONE" - No compatibility check.
	//   "BACKWARD" - Backwards compatible with the most recent version.
	//   "BACKWARD_TRANSITIVE" - Backwards compatible with all previous versions.
	//   "FORWARD" - Forwards compatible with the most recent version.
	//   "FORWARD_TRANSITIVE" - Forwards compatible with all previous versions.
	//   "FULL" - Backwards and forwards compatible with the most recent version.
	//   "FULL_TRANSITIVE" - Backwards and forwards compatible with all previous
	// versions.
	Compatibility string `json:"compatibility,omitempty"`
	// Normalize: Optional. If true, the schema will be normalized before being
	// stored or looked up. The default is false. Cannot be unset for a
	// SchemaRegistry-level SchemaConfig. If unset on a SchemaSubject-level
	// SchemaConfig, removes the normalize field for the SchemaConfig.
	Normalize bool `json:"normalize,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Compatibility") to
	// unconditionally include in API requests. By default, fields with empty or
	// default values are omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Compatibility") to include in API
	// requests with the JSON null value. By default, fields with empty values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s UpdateSchemaConfigRequest) MarshalJSON() ([]byte, error) {
	type NoMethod UpdateSchemaConfigRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

// UpdateSchemaModeRequest: Request for updating schema registry or subject
// mode.
type UpdateSchemaModeRequest struct {
	// Mode: Required. The mode type.
	//
	// Possible values:
	//   "NONE" - No mode.
	//   "READONLY" - READONLY mode.
	//   "READWRITE" - READWRITE mode.
	//   "IMPORT" - IMPORT mode.
	Mode string `json:"mode,omitempty"`
	// ForceSendFields is a list of field names (e.g. "Mode") to unconditionally
	// include in API requests. By default, fields with empty or default values are
	// omitted from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-ForceSendFields for more
	// details.
	ForceSendFields []string `json:"-"`
	// NullFields is a list of field names (e.g. "Mode") to include in API requests
	// with the JSON null value. By default, fields with empty values are omitted
	// from API requests. See
	// https://pkg.go.dev/google.golang.org/api#hdr-NullFields for more details.
	NullFields []string `json:"-"`
}

func (s UpdateSchemaModeRequest) MarshalJSON() ([]byte, error) {
	type NoMethod UpdateSchemaModeRequest
	return gensupport.MarshalJSON(NoMethod(s), s.ForceSendFields, s.NullFields)
}

type ProjectsLocationsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Gets information about a location.
//
// - name: Resource name for the location.
func (r *ProjectsLocationsService) Get(name string) *ProjectsLocationsGetCall {
	c := &ProjectsLocationsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsGetCall) Context(ctx context.Context) *ProjectsLocationsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Location.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsGetCall) Do(opts ...googleapi.CallOption) (*Location, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Location{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsListCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists information about the supported locations for this service.
//
// - name: The resource that owns the locations collection, if applicable.
func (r *ProjectsLocationsService) List(name string) *ProjectsLocationsListCall {
	c := &ProjectsLocationsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// ExtraLocationTypes sets the optional parameter "extraLocationTypes": A list
// of extra location types that should be used as conditions for controlling
// the visibility of the locations.
func (c *ProjectsLocationsListCall) ExtraLocationTypes(extraLocationTypes ...string) *ProjectsLocationsListCall {
	c.urlParams_.SetMulti("extraLocationTypes", append([]string{}, extraLocationTypes...))
	return c
}

// Filter sets the optional parameter "filter": A filter to narrow down results
// to a preferred subset. The filtering language accepts strings like
// "displayName=tokyo", and is documented in more detail in AIP-160
// (https://google.aip.dev/160).
func (c *ProjectsLocationsListCall) Filter(filter string) *ProjectsLocationsListCall {
	c.urlParams_.Set("filter", filter)
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// results to return. If not set, the service selects a default.
func (c *ProjectsLocationsListCall) PageSize(pageSize int64) *ProjectsLocationsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token received
// from the `next_page_token` field in the response. Send that page token to
// receive the subsequent page.
func (c *ProjectsLocationsListCall) PageToken(pageToken string) *ProjectsLocationsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsListCall) Context(ctx context.Context) *ProjectsLocationsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/locations")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListLocationsResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsListCall) Do(opts ...googleapi.CallOption) (*ListLocationsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListLocationsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsListCall) Pages(ctx context.Context, f func(*ListLocationsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsClustersCreateCall struct {
	s          *Service
	parent     string
	cluster    *Cluster
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Create: Creates a new cluster in a given project and location.
//
//   - parent: The parent region in which to create the cluster. Structured like
//     `projects/{project}/locations/{location}`.
func (r *ProjectsLocationsClustersService) Create(parent string, cluster *Cluster) *ProjectsLocationsClustersCreateCall {
	c := &ProjectsLocationsClustersCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.cluster = cluster
	return c
}

// ClusterId sets the optional parameter "clusterId": Required. The ID to use
// for the cluster, which will become the final component of the cluster's
// name. The ID must be 1-63 characters long, and match the regular expression
// `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value is
// structured like: `my-cluster-id`.
func (c *ProjectsLocationsClustersCreateCall) ClusterId(clusterId string) *ProjectsLocationsClustersCreateCall {
	c.urlParams_.Set("clusterId", clusterId)
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsClustersCreateCall) RequestId(requestId string) *ProjectsLocationsClustersCreateCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersCreateCall) Context(ctx context.Context) *ProjectsLocationsClustersCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.cluster)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/clusters")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersCreateCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a single cluster.
//
// - name: The name of the cluster to delete.
func (r *ProjectsLocationsClustersService) Delete(name string) *ProjectsLocationsClustersDeleteCall {
	c := &ProjectsLocationsClustersDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsClustersDeleteCall) RequestId(requestId string) *ProjectsLocationsClustersDeleteCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersDeleteCall) Context(ctx context.Context) *ProjectsLocationsClustersDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersDeleteCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single cluster.
//
// - name: The name of the cluster whose configuration to return.
func (r *ProjectsLocationsClustersService) Get(name string) *ProjectsLocationsClustersGetCall {
	c := &ProjectsLocationsClustersGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersGetCall) Context(ctx context.Context) *ProjectsLocationsClustersGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Cluster.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersGetCall) Do(opts ...googleapi.CallOption) (*Cluster, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Cluster{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the clusters in a given project and location.
//
//   - parent: The parent location whose clusters are to be listed. Structured
//     like `projects/{project}/locations/{location}`.
func (r *ProjectsLocationsClustersService) List(parent string) *ProjectsLocationsClustersListCall {
	c := &ProjectsLocationsClustersListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Filter sets the optional parameter "filter": Filter expression for the
// result.
func (c *ProjectsLocationsClustersListCall) Filter(filter string) *ProjectsLocationsClustersListCall {
	c.urlParams_.Set("filter", filter)
	return c
}

// OrderBy sets the optional parameter "orderBy": Order by fields for the
// result.
func (c *ProjectsLocationsClustersListCall) OrderBy(orderBy string) *ProjectsLocationsClustersListCall {
	c.urlParams_.Set("orderBy", orderBy)
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// clusters to return. The service may return fewer than this value. If
// unspecified, server will pick an appropriate default.
func (c *ProjectsLocationsClustersListCall) PageSize(pageSize int64) *ProjectsLocationsClustersListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListClusters` call. Provide this to retrieve the subsequent
// page. When paginating, all other parameters provided to `ListClusters` must
// match the call that provided the page token.
func (c *ProjectsLocationsClustersListCall) PageToken(pageToken string) *ProjectsLocationsClustersListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersListCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersListCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersListCall) Context(ctx context.Context) *ProjectsLocationsClustersListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/clusters")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListClustersResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsClustersListCall) Do(opts ...googleapi.CallOption) (*ListClustersResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListClustersResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsClustersListCall) Pages(ctx context.Context, f func(*ListClustersResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsClustersPatchCall struct {
	s          *Service
	name       string
	cluster    *Cluster
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Patch: Updates the properties of a single cluster.
//
//   - name: Identifier. The name of the cluster. Structured like:
//     projects/{project_number}/locations/{location}/clusters/{cluster_id}.
func (r *ProjectsLocationsClustersService) Patch(name string, cluster *Cluster) *ProjectsLocationsClustersPatchCall {
	c := &ProjectsLocationsClustersPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.cluster = cluster
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsClustersPatchCall) RequestId(requestId string) *ProjectsLocationsClustersPatchCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// UpdateMask sets the optional parameter "updateMask": Required. Field mask is
// used to specify the fields to be overwritten in the cluster resource by the
// update. The fields specified in the update_mask are relative to the
// resource, not the full request. A field will be overwritten if it is in the
// mask. The mask is required and a value of * will update all fields.
func (c *ProjectsLocationsClustersPatchCall) UpdateMask(updateMask string) *ProjectsLocationsClustersPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersPatchCall) Context(ctx context.Context) *ProjectsLocationsClustersPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.cluster)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersPatchCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsAddAclEntryCall struct {
	s          *Service
	acl        string
	aclentry   *AclEntry
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// AddAclEntry: Incremental update: Adds an acl entry to an acl. Creates the
// acl if it does not exist yet.
//
//   - acl: The name of the acl to add the acl entry to. Structured like:
//     `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
//     The structure of `acl_id` defines the Resource Pattern (resource_type,
//     resource_name, pattern_type) of the acl. See `Acl.name` for details.
func (r *ProjectsLocationsClustersAclsService) AddAclEntry(acl string, aclentry *AclEntry) *ProjectsLocationsClustersAclsAddAclEntryCall {
	c := &ProjectsLocationsClustersAclsAddAclEntryCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.acl = acl
	c.aclentry = aclentry
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsAddAclEntryCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsAddAclEntryCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsAddAclEntryCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsAddAclEntryCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsAddAclEntryCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsAddAclEntryCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.aclentry)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+acl}:addAclEntry")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"acl": c.acl,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.addAclEntry", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.addAclEntry" call.
// Any non-2xx status code is an error. Response headers are in either
// *AddAclEntryResponse.ServerResponse.Header or (if a response was returned at
// all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsClustersAclsAddAclEntryCall) Do(opts ...googleapi.CallOption) (*AddAclEntryResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &AddAclEntryResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.addAclEntry", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsCreateCall struct {
	s          *Service
	parent     string
	acl        *Acl
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Create: Creates a new acl in the given project, location, and cluster.
//
//   - parent: The parent cluster in which to create the acl. Structured like
//     `projects/{project}/locations/{location}/clusters/{cluster}`.
func (r *ProjectsLocationsClustersAclsService) Create(parent string, acl *Acl) *ProjectsLocationsClustersAclsCreateCall {
	c := &ProjectsLocationsClustersAclsCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.acl = acl
	return c
}

// AclId sets the optional parameter "aclId": Required. The ID to use for the
// acl, which will become the final component of the acl's name. The structure
// of `acl_id` defines the Resource Pattern (resource_type, resource_name,
// pattern_type) of the acl. `acl_id` is structured like one of the following:
// For acls on the cluster: `cluster` For acls on a single resource within the
// cluster: `topic/{resource_name}` `consumerGroup/{resource_name}`
// `transactionalId/{resource_name}` For acls on all resources that match a
// prefix: `topicPrefixed/{resource_name}`
// `consumerGroupPrefixed/{resource_name}`
// `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
// given type (i.e. the wildcard literal "*"): `allTopics` (represents
// `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`)
// `allTransactionalIds` (represents `transactionalId/*`)
func (c *ProjectsLocationsClustersAclsCreateCall) AclId(aclId string) *ProjectsLocationsClustersAclsCreateCall {
	c.urlParams_.Set("aclId", aclId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsCreateCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.acl)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/acls")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *Acl.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersAclsCreateCall) Do(opts ...googleapi.CallOption) (*Acl, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Acl{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes an acl.
//
//   - name: The name of the acl to delete. Structured like:
//     `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
//     The structure of `acl_id` defines the Resource Pattern (resource_type,
//     resource_name, pattern_type) of the acl. See `Acl.name` for details.
func (r *ProjectsLocationsClustersAclsService) Delete(name string) *ProjectsLocationsClustersAclsDeleteCall {
	c := &ProjectsLocationsClustersAclsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsDeleteCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersAclsDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single acl.
//
//   - name: The name of the acl to return. Structured like:
//     `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
//     The structure of `acl_id` defines the Resource Pattern (resource_type,
//     resource_name, pattern_type) of the acl. See `Acl.name` for details.
func (r *ProjectsLocationsClustersAclsService) Get(name string) *ProjectsLocationsClustersAclsGetCall {
	c := &ProjectsLocationsClustersAclsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersAclsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersAclsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsGetCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Acl.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersAclsGetCall) Do(opts ...googleapi.CallOption) (*Acl, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Acl{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the acls in a given cluster.
//
//   - parent: The parent cluster whose acls are to be listed. Structured like
//     `projects/{project}/locations/{location}/clusters/{cluster}`.
func (r *ProjectsLocationsClustersAclsService) List(parent string) *ProjectsLocationsClustersAclsListCall {
	c := &ProjectsLocationsClustersAclsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of acls
// to return. The service may return fewer than this value. If unset or zero,
// all acls for the parent is returned.
func (c *ProjectsLocationsClustersAclsListCall) PageSize(pageSize int64) *ProjectsLocationsClustersAclsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListAcls` call. Provide this to retrieve the subsequent
// page. When paginating, all other parameters provided to `ListAcls` must
// match the call that provided the page token.
func (c *ProjectsLocationsClustersAclsListCall) PageToken(pageToken string) *ProjectsLocationsClustersAclsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersAclsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersAclsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsListCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/acls")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListAclsResponse.ServerResponse.Header or (if a response was returned at
// all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsClustersAclsListCall) Do(opts ...googleapi.CallOption) (*ListAclsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListAclsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsClustersAclsListCall) Pages(ctx context.Context, f func(*ListAclsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsClustersAclsPatchCall struct {
	s          *Service
	name       string
	acl        *Acl
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Patch: Updates the properties of a single acl.
//
//   - name: Identifier. The name for the acl. Represents a single Resource
//     Pattern. Structured like:
//     projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}
//     The structure of `acl_id` defines the Resource Pattern (resource_type,
//     resource_name, pattern_type) of the acl. `acl_id` is structured like one
//     of the following: For acls on the cluster: `cluster` For acls on a single
//     resource within the cluster: `topic/{resource_name}`
//     `consumerGroup/{resource_name}` `transactionalId/{resource_name}` For acls
//     on all resources that match a prefix: `topicPrefixed/{resource_name}`
//     `consumerGroupPrefixed/{resource_name}`
//     `transactionalIdPrefixed/{resource_name}` For acls on all resources of a
//     given type (i.e. the wildcard literal "*"): `allTopics` (represents
//     `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`)
//     `allTransactionalIds` (represents `transactionalId/*`).
func (r *ProjectsLocationsClustersAclsService) Patch(name string, acl *Acl) *ProjectsLocationsClustersAclsPatchCall {
	c := &ProjectsLocationsClustersAclsPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.acl = acl
	return c
}

// UpdateMask sets the optional parameter "updateMask": Field mask is used to
// specify the fields to be overwritten in the Acl resource by the update. The
// fields specified in the update_mask are relative to the resource, not the
// full request. A field will be overwritten if it is in the mask.
func (c *ProjectsLocationsClustersAclsPatchCall) UpdateMask(updateMask string) *ProjectsLocationsClustersAclsPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsPatchCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.acl)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *Acl.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersAclsPatchCall) Do(opts ...googleapi.CallOption) (*Acl, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Acl{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersAclsRemoveAclEntryCall struct {
	s          *Service
	acl        string
	aclentry   *AclEntry
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// RemoveAclEntry: Incremental update: Removes an acl entry from an acl.
// Deletes the acl if its acl entries become empty (i.e. if the removed entry
// was the last one in the acl).
//
//   - acl: The name of the acl to remove the acl entry from. Structured like:
//     `projects/{project}/locations/{location}/clusters/{cluster}/acls/{acl_id}`.
//     The structure of `acl_id` defines the Resource Pattern (resource_type,
//     resource_name, pattern_type) of the acl. See `Acl.name` for details.
func (r *ProjectsLocationsClustersAclsService) RemoveAclEntry(acl string, aclentry *AclEntry) *ProjectsLocationsClustersAclsRemoveAclEntryCall {
	c := &ProjectsLocationsClustersAclsRemoveAclEntryCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.acl = acl
	c.aclentry = aclentry
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersAclsRemoveAclEntryCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersAclsRemoveAclEntryCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersAclsRemoveAclEntryCall) Context(ctx context.Context) *ProjectsLocationsClustersAclsRemoveAclEntryCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersAclsRemoveAclEntryCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersAclsRemoveAclEntryCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.aclentry)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+acl}:removeAclEntry")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"acl": c.acl,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.removeAclEntry", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.acls.removeAclEntry" call.
// Any non-2xx status code is an error. Response headers are in either
// *RemoveAclEntryResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsClustersAclsRemoveAclEntryCall) Do(opts ...googleapi.CallOption) (*RemoveAclEntryResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &RemoveAclEntryResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.acls.removeAclEntry", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersConsumerGroupsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a single consumer group.
//
//   - name: The name of the consumer group to delete.
//     `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/
//     {consumerGroup}`.
func (r *ProjectsLocationsClustersConsumerGroupsService) Delete(name string) *ProjectsLocationsClustersConsumerGroupsDeleteCall {
	c := &ProjectsLocationsClustersConsumerGroupsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersConsumerGroupsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersConsumerGroupsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersConsumerGroupsDeleteCall) Context(ctx context.Context) *ProjectsLocationsClustersConsumerGroupsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersConsumerGroupsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersConsumerGroupsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.consumerGroups.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersConsumerGroupsDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersConsumerGroupsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single consumer group.
//
//   - name: The name of the consumer group whose configuration to return.
//     `projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/
//     {consumerGroup}`.
func (r *ProjectsLocationsClustersConsumerGroupsService) Get(name string) *ProjectsLocationsClustersConsumerGroupsGetCall {
	c := &ProjectsLocationsClustersConsumerGroupsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersConsumerGroupsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersConsumerGroupsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersConsumerGroupsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersConsumerGroupsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersConsumerGroupsGetCall) Context(ctx context.Context) *ProjectsLocationsClustersConsumerGroupsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersConsumerGroupsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersConsumerGroupsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.consumerGroups.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *ConsumerGroup.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersConsumerGroupsGetCall) Do(opts ...googleapi.CallOption) (*ConsumerGroup, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ConsumerGroup{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersConsumerGroupsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the consumer groups in a given cluster.
//
//   - parent: The parent cluster whose consumer groups are to be listed.
//     Structured like
//     `projects/{project}/locations/{location}/clusters/{cluster}`.
func (r *ProjectsLocationsClustersConsumerGroupsService) List(parent string) *ProjectsLocationsClustersConsumerGroupsListCall {
	c := &ProjectsLocationsClustersConsumerGroupsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// consumer groups to return. The service may return fewer than this value. If
// unset or zero, all consumer groups for the parent is returned.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) PageSize(pageSize int64) *ProjectsLocationsClustersConsumerGroupsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListConsumerGroups` call. Provide this to retrieve the
// subsequent page. When paginating, all other parameters provided to
// `ListConsumerGroups` must match the call that provided the page token.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) PageToken(pageToken string) *ProjectsLocationsClustersConsumerGroupsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersConsumerGroupsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersConsumerGroupsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) Context(ctx context.Context) *ProjectsLocationsClustersConsumerGroupsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersConsumerGroupsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/consumerGroups")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.consumerGroups.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListConsumerGroupsResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) Do(opts ...googleapi.CallOption) (*ListConsumerGroupsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListConsumerGroupsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsClustersConsumerGroupsListCall) Pages(ctx context.Context, f func(*ListConsumerGroupsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsClustersConsumerGroupsPatchCall struct {
	s             *Service
	name          string
	consumergroup *ConsumerGroup
	urlParams_    gensupport.URLParams
	ctx_          context.Context
	header_       http.Header
}

// Patch: Updates the properties of a single consumer group.
//
//   - name: Identifier. The name of the consumer group. The `consumer_group`
//     segment is used when connecting directly to the cluster. Structured like:
//     projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{
//     consumer_group}.
func (r *ProjectsLocationsClustersConsumerGroupsService) Patch(name string, consumergroup *ConsumerGroup) *ProjectsLocationsClustersConsumerGroupsPatchCall {
	c := &ProjectsLocationsClustersConsumerGroupsPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.consumergroup = consumergroup
	return c
}

// UpdateMask sets the optional parameter "updateMask": Required. Field mask is
// used to specify the fields to be overwritten in the ConsumerGroup resource
// by the update. The fields specified in the update_mask are relative to the
// resource, not the full request. A field will be overwritten if it is in the
// mask. The mask is required and a value of * will update all fields.
func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) UpdateMask(updateMask string) *ProjectsLocationsClustersConsumerGroupsPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersConsumerGroupsPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) Context(ctx context.Context) *ProjectsLocationsClustersConsumerGroupsPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.consumergroup)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.consumerGroups.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *ConsumerGroup.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersConsumerGroupsPatchCall) Do(opts ...googleapi.CallOption) (*ConsumerGroup, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ConsumerGroup{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.consumerGroups.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersTopicsCreateCall struct {
	s          *Service
	parent     string
	topic      *Topic
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Create: Creates a new topic in a given project and location.
//
//   - parent: The parent cluster in which to create the topic. Structured like
//     `projects/{project}/locations/{location}/clusters/{cluster}`.
func (r *ProjectsLocationsClustersTopicsService) Create(parent string, topic *Topic) *ProjectsLocationsClustersTopicsCreateCall {
	c := &ProjectsLocationsClustersTopicsCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.topic = topic
	return c
}

// TopicId sets the optional parameter "topicId": Required. The ID to use for
// the topic, which will become the final component of the topic's name. This
// value is structured like: `my-topic-name`.
func (c *ProjectsLocationsClustersTopicsCreateCall) TopicId(topicId string) *ProjectsLocationsClustersTopicsCreateCall {
	c.urlParams_.Set("topicId", topicId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersTopicsCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersTopicsCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersTopicsCreateCall) Context(ctx context.Context) *ProjectsLocationsClustersTopicsCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersTopicsCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersTopicsCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.topic)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/topics")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.topics.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *Topic.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersTopicsCreateCall) Do(opts ...googleapi.CallOption) (*Topic, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Topic{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersTopicsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a single topic.
//
//   - name: The name of the topic to delete.
//     `projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}`
//     .
func (r *ProjectsLocationsClustersTopicsService) Delete(name string) *ProjectsLocationsClustersTopicsDeleteCall {
	c := &ProjectsLocationsClustersTopicsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersTopicsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersTopicsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersTopicsDeleteCall) Context(ctx context.Context) *ProjectsLocationsClustersTopicsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersTopicsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersTopicsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.topics.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersTopicsDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersTopicsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single topic.
//
//   - name: The name of the topic whose configuration to return. Structured
//     like:
//     projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
func (r *ProjectsLocationsClustersTopicsService) Get(name string) *ProjectsLocationsClustersTopicsGetCall {
	c := &ProjectsLocationsClustersTopicsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersTopicsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersTopicsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersTopicsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersTopicsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersTopicsGetCall) Context(ctx context.Context) *ProjectsLocationsClustersTopicsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersTopicsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersTopicsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.topics.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Topic.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersTopicsGetCall) Do(opts ...googleapi.CallOption) (*Topic, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Topic{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsClustersTopicsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the topics in a given cluster.
//
//   - parent: The parent cluster whose topics are to be listed. Structured like
//     `projects/{project}/locations/{location}/clusters/{cluster}`.
func (r *ProjectsLocationsClustersTopicsService) List(parent string) *ProjectsLocationsClustersTopicsListCall {
	c := &ProjectsLocationsClustersTopicsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// topics to return. The service may return fewer than this value. If unset or
// zero, all topics for the parent is returned.
func (c *ProjectsLocationsClustersTopicsListCall) PageSize(pageSize int64) *ProjectsLocationsClustersTopicsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListTopics` call. Provide this to retrieve the subsequent
// page. When paginating, all other parameters provided to `ListTopics` must
// match the call that provided the page token.
func (c *ProjectsLocationsClustersTopicsListCall) PageToken(pageToken string) *ProjectsLocationsClustersTopicsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersTopicsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersTopicsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsClustersTopicsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsClustersTopicsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersTopicsListCall) Context(ctx context.Context) *ProjectsLocationsClustersTopicsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersTopicsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersTopicsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/topics")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.topics.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListTopicsResponse.ServerResponse.Header or (if a response was returned at
// all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsClustersTopicsListCall) Do(opts ...googleapi.CallOption) (*ListTopicsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListTopicsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsClustersTopicsListCall) Pages(ctx context.Context, f func(*ListTopicsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsClustersTopicsPatchCall struct {
	s          *Service
	name       string
	topic      *Topic
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Patch: Updates the properties of a single topic.
//
//   - name: Identifier. The name of the topic. The `topic` segment is used when
//     connecting directly to the cluster. Structured like:
//     projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.
func (r *ProjectsLocationsClustersTopicsService) Patch(name string, topic *Topic) *ProjectsLocationsClustersTopicsPatchCall {
	c := &ProjectsLocationsClustersTopicsPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.topic = topic
	return c
}

// UpdateMask sets the optional parameter "updateMask": Required. Field mask is
// used to specify the fields to be overwritten in the Topic resource by the
// update. The fields specified in the update_mask are relative to the
// resource, not the full request. A field will be overwritten if it is in the
// mask. The mask is required and a value of * will update all fields.
func (c *ProjectsLocationsClustersTopicsPatchCall) UpdateMask(updateMask string) *ProjectsLocationsClustersTopicsPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsClustersTopicsPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsClustersTopicsPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsClustersTopicsPatchCall) Context(ctx context.Context) *ProjectsLocationsClustersTopicsPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsClustersTopicsPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsClustersTopicsPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.topic)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.clusters.topics.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *Topic.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsClustersTopicsPatchCall) Do(opts ...googleapi.CallOption) (*Topic, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Topic{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.clusters.topics.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersCreateCall struct {
	s              *Service
	parent         string
	connectcluster *ConnectCluster
	urlParams_     gensupport.URLParams
	ctx_           context.Context
	header_        http.Header
}

// Create: Creates a new Kafka Connect cluster in a given project and location.
//
//   - parent: The parent project/location in which to create the Kafka Connect
//     cluster. Structured like `projects/{project}/locations/{location}/`.
func (r *ProjectsLocationsConnectClustersService) Create(parent string, connectcluster *ConnectCluster) *ProjectsLocationsConnectClustersCreateCall {
	c := &ProjectsLocationsConnectClustersCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.connectcluster = connectcluster
	return c
}

// ConnectClusterId sets the optional parameter "connectClusterId": Required.
// The ID to use for the Connect cluster, which will become the final component
// of the cluster's name. The ID must be 1-63 characters long, and match the
// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035.
// This value is structured like: `my-cluster-id`.
func (c *ProjectsLocationsConnectClustersCreateCall) ConnectClusterId(connectClusterId string) *ProjectsLocationsConnectClustersCreateCall {
	c.urlParams_.Set("connectClusterId", connectClusterId)
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsConnectClustersCreateCall) RequestId(requestId string) *ProjectsLocationsConnectClustersCreateCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersCreateCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.connectcluster)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/connectClusters")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersCreateCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a single Connect cluster.
//
//   - name: The name of the Kafka Connect cluster to delete. Structured like
//     `projects/{project}/locations/{location}/connectClusters/{connect_cluster_i
//     d}`.
func (r *ProjectsLocationsConnectClustersService) Delete(name string) *ProjectsLocationsConnectClustersDeleteCall {
	c := &ProjectsLocationsConnectClustersDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsConnectClustersDeleteCall) RequestId(requestId string) *ProjectsLocationsConnectClustersDeleteCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersDeleteCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersDeleteCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single Kafka Connect cluster.
//
//   - name: The name of the Kafka Connect cluster whose configuration to return.
//     Structured like
//     `projects/{project}/locations/{location}/connectClusters/{connect_cluster_i
//     d}`.
func (r *ProjectsLocationsConnectClustersService) Get(name string) *ProjectsLocationsConnectClustersGetCall {
	c := &ProjectsLocationsConnectClustersGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsConnectClustersGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsConnectClustersGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersGetCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *ConnectCluster.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersGetCall) Do(opts ...googleapi.CallOption) (*ConnectCluster, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ConnectCluster{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the Kafka Connect clusters in a given project and location.
//
//   - parent: The parent project/location whose Connect clusters are to be
//     listed. Structured like `projects/{project}/locations/{location}`.
func (r *ProjectsLocationsConnectClustersService) List(parent string) *ProjectsLocationsConnectClustersListCall {
	c := &ProjectsLocationsConnectClustersListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Filter sets the optional parameter "filter": Filter expression for the
// result.
func (c *ProjectsLocationsConnectClustersListCall) Filter(filter string) *ProjectsLocationsConnectClustersListCall {
	c.urlParams_.Set("filter", filter)
	return c
}

// OrderBy sets the optional parameter "orderBy": Order by fields for the
// result.
func (c *ProjectsLocationsConnectClustersListCall) OrderBy(orderBy string) *ProjectsLocationsConnectClustersListCall {
	c.urlParams_.Set("orderBy", orderBy)
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// Connect clusters to return. The service may return fewer than this value. If
// unspecified, server will pick an appropriate default.
func (c *ProjectsLocationsConnectClustersListCall) PageSize(pageSize int64) *ProjectsLocationsConnectClustersListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListConnectClusters` call. Provide this to retrieve the
// subsequent page. When paginating, all other parameters provided to
// `ListConnectClusters` must match the call that provided the page token.
func (c *ProjectsLocationsConnectClustersListCall) PageToken(pageToken string) *ProjectsLocationsConnectClustersListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersListCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsConnectClustersListCall) IfNoneMatch(entityTag string) *ProjectsLocationsConnectClustersListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersListCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/connectClusters")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListConnectClustersResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersListCall) Do(opts ...googleapi.CallOption) (*ListConnectClustersResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListConnectClustersResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsConnectClustersListCall) Pages(ctx context.Context, f func(*ListConnectClustersResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsConnectClustersPatchCall struct {
	s              *Service
	name           string
	connectcluster *ConnectCluster
	urlParams_     gensupport.URLParams
	ctx_           context.Context
	header_        http.Header
}

// Patch: Updates the properties of a single Kafka Connect cluster.
//
//   - name: Identifier. The name of the Kafka Connect cluster. Structured like:
//     projects/{project_number}/locations/{location}/connectClusters/{connect_clu
//     ster_id}.
func (r *ProjectsLocationsConnectClustersService) Patch(name string, connectcluster *ConnectCluster) *ProjectsLocationsConnectClustersPatchCall {
	c := &ProjectsLocationsConnectClustersPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.connectcluster = connectcluster
	return c
}

// RequestId sets the optional parameter "requestId": An optional request ID to
// identify requests. Specify a unique request ID to avoid duplication of
// requests. If a request times out or fails, retrying with the same ID allows
// the server to recognize the previous attempt. For at least 60 minutes, the
// server ignores duplicate requests bearing the same ID. For example, consider
// a situation where you make an initial request and the request times out. If
// you make the request again with the same request ID within 60 minutes of the
// last request, the server checks if an original operation with the same
// request ID was received. If so, the server ignores the second request. The
// request ID must be a valid UUID. A zero UUID is not supported
// (00000000-0000-0000-0000-000000000000).
func (c *ProjectsLocationsConnectClustersPatchCall) RequestId(requestId string) *ProjectsLocationsConnectClustersPatchCall {
	c.urlParams_.Set("requestId", requestId)
	return c
}

// UpdateMask sets the optional parameter "updateMask": Required. Field mask is
// used to specify the fields to be overwritten in the cluster resource by the
// update. The fields specified in the update_mask are relative to the
// resource, not the full request. A field will be overwritten if it is in the
// mask. The mask is required and a value of * will update all fields.
func (c *ProjectsLocationsConnectClustersPatchCall) UpdateMask(updateMask string) *ProjectsLocationsConnectClustersPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersPatchCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.connectcluster)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersPatchCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsCreateCall struct {
	s          *Service
	parent     string
	connector  *Connector
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Create: Creates a new connector in a given Connect cluster.
//
//   - parent: The parent Connect cluster in which to create the connector.
//     Structured like
//     `projects/{project}/locations/{location}/connectClusters/{connect_cluster_i
//     d}`.
func (r *ProjectsLocationsConnectClustersConnectorsService) Create(parent string, connector *Connector) *ProjectsLocationsConnectClustersConnectorsCreateCall {
	c := &ProjectsLocationsConnectClustersConnectorsCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.connector = connector
	return c
}

// ConnectorId sets the optional parameter "connectorId": Required. The ID to
// use for the connector, which will become the final component of the
// connector's name. The ID must be 1-63 characters long, and match the regular
// expression `[a-z]([-a-z0-9]*[a-z0-9])?` to comply with RFC 1035. This value
// is structured like: `my-connector-id`.
func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) ConnectorId(connectorId string) *ProjectsLocationsConnectClustersConnectorsCreateCall {
	c.urlParams_.Set("connectorId", connectorId)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.connector)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/connectors")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *Connector.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsCreateCall) Do(opts ...googleapi.CallOption) (*Connector, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Connector{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a connector.
//
//   - name: The name of the connector to delete. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Delete(name string) *ProjectsLocationsConnectClustersConnectorsDeleteCall {
	c := &ProjectsLocationsConnectClustersConnectorsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsDeleteCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Returns the properties of a single connector.
//
//   - name: The name of the connector whose configuration to return. Structured
//     like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Get(name string) *ProjectsLocationsConnectClustersConnectorsGetCall {
	c := &ProjectsLocationsConnectClustersConnectorsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsConnectClustersConnectorsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsConnectClustersConnectorsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsGetCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Connector.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsGetCall) Do(opts ...googleapi.CallOption) (*Connector, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Connector{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists the connectors in a given Connect cluster.
//
//   - parent: The parent Connect cluster whose connectors are to be listed.
//     Structured like
//     `projects/{project}/locations/{location}/connectClusters/{connect_cluster_i
//     d}`.
func (r *ProjectsLocationsConnectClustersConnectorsService) List(parent string) *ProjectsLocationsConnectClustersConnectorsListCall {
	c := &ProjectsLocationsConnectClustersConnectorsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// PageSize sets the optional parameter "pageSize": The maximum number of
// connectors to return. The service may return fewer than this value. If
// unspecified, server will pick an appropriate default.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) PageSize(pageSize int64) *ProjectsLocationsConnectClustersConnectorsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": A page token, received
// from a previous `ListConnectors` call. Provide this to retrieve the
// subsequent page. When paginating, all other parameters provided to
// `ListConnectors` must match the call that provided the page token.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) PageToken(pageToken string) *ProjectsLocationsConnectClustersConnectorsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsConnectClustersConnectorsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/connectors")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListConnectorsResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) Do(opts ...googleapi.CallOption) (*ListConnectorsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListConnectorsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsConnectClustersConnectorsListCall) Pages(ctx context.Context, f func(*ListConnectorsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsConnectClustersConnectorsPatchCall struct {
	s          *Service
	name       string
	connector  *Connector
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Patch: Updates the properties of a connector.
//
//   - name: Identifier. The name of the connector. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connect_cluster}/c
//     onnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Patch(name string, connector *Connector) *ProjectsLocationsConnectClustersConnectorsPatchCall {
	c := &ProjectsLocationsConnectClustersConnectorsPatchCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.connector = connector
	return c
}

// UpdateMask sets the optional parameter "updateMask": Required. Field mask is
// used to specify the fields to be overwritten in the cluster resource by the
// update. The fields specified in the update_mask are relative to the
// resource, not the full request. A field will be overwritten if it is in the
// mask. The mask is required and a value of * will update all fields.
func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) UpdateMask(updateMask string) *ProjectsLocationsConnectClustersConnectorsPatchCall {
	c.urlParams_.Set("updateMask", updateMask)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsPatchCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsPatchCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.connector)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PATCH", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.patch", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.patch" call.
// Any non-2xx status code is an error. Response headers are in either
// *Connector.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsPatchCall) Do(opts ...googleapi.CallOption) (*Connector, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Connector{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.patch", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsPauseCall struct {
	s                     *Service
	name                  string
	pauseconnectorrequest *PauseConnectorRequest
	urlParams_            gensupport.URLParams
	ctx_                  context.Context
	header_               http.Header
}

// Pause: Pauses the connector and its tasks.
//
//   - name: The name of the connector to pause. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Pause(name string, pauseconnectorrequest *PauseConnectorRequest) *ProjectsLocationsConnectClustersConnectorsPauseCall {
	c := &ProjectsLocationsConnectClustersConnectorsPauseCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.pauseconnectorrequest = pauseconnectorrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsPauseCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsPauseCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsPauseCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsPauseCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsPauseCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsPauseCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.pauseconnectorrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}:pause")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.pause", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.pause" call.
// Any non-2xx status code is an error. Response headers are in either
// *PauseConnectorResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsConnectClustersConnectorsPauseCall) Do(opts ...googleapi.CallOption) (*PauseConnectorResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &PauseConnectorResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.pause", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsRestartCall struct {
	s                       *Service
	name                    string
	restartconnectorrequest *RestartConnectorRequest
	urlParams_              gensupport.URLParams
	ctx_                    context.Context
	header_                 http.Header
}

// Restart: Restarts the connector.
//
//   - name: The name of the connector to restart. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Restart(name string, restartconnectorrequest *RestartConnectorRequest) *ProjectsLocationsConnectClustersConnectorsRestartCall {
	c := &ProjectsLocationsConnectClustersConnectorsRestartCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.restartconnectorrequest = restartconnectorrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsRestartCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsRestartCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsRestartCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsRestartCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsRestartCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsRestartCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.restartconnectorrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}:restart")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.restart", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.restart" call.
// Any non-2xx status code is an error. Response headers are in either
// *RestartConnectorResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsRestartCall) Do(opts ...googleapi.CallOption) (*RestartConnectorResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &RestartConnectorResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.restart", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsResumeCall struct {
	s                      *Service
	name                   string
	resumeconnectorrequest *ResumeConnectorRequest
	urlParams_             gensupport.URLParams
	ctx_                   context.Context
	header_                http.Header
}

// Resume: Resumes the connector and its tasks.
//
//   - name: The name of the connector to pause. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Resume(name string, resumeconnectorrequest *ResumeConnectorRequest) *ProjectsLocationsConnectClustersConnectorsResumeCall {
	c := &ProjectsLocationsConnectClustersConnectorsResumeCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.resumeconnectorrequest = resumeconnectorrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsResumeCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsResumeCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsResumeCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsResumeCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsResumeCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsResumeCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.resumeconnectorrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}:resume")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.resume", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.resume" call.
// Any non-2xx status code is an error. Response headers are in either
// *ResumeConnectorResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsConnectClustersConnectorsResumeCall) Do(opts ...googleapi.CallOption) (*ResumeConnectorResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ResumeConnectorResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.resume", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsConnectClustersConnectorsStopCall struct {
	s                    *Service
	name                 string
	stopconnectorrequest *StopConnectorRequest
	urlParams_           gensupport.URLParams
	ctx_                 context.Context
	header_              http.Header
}

// Stop: Stops the connector.
//
//   - name: The name of the connector to stop. Structured like:
//     projects/{project}/locations/{location}/connectClusters/{connectCluster}/co
//     nnectors/{connector}.
func (r *ProjectsLocationsConnectClustersConnectorsService) Stop(name string, stopconnectorrequest *StopConnectorRequest) *ProjectsLocationsConnectClustersConnectorsStopCall {
	c := &ProjectsLocationsConnectClustersConnectorsStopCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.stopconnectorrequest = stopconnectorrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsConnectClustersConnectorsStopCall) Fields(s ...googleapi.Field) *ProjectsLocationsConnectClustersConnectorsStopCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsConnectClustersConnectorsStopCall) Context(ctx context.Context) *ProjectsLocationsConnectClustersConnectorsStopCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsConnectClustersConnectorsStopCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsConnectClustersConnectorsStopCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.stopconnectorrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}:stop")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.stop", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.connectClusters.connectors.stop" call.
// Any non-2xx status code is an error. Response headers are in either
// *StopConnectorResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsConnectClustersConnectorsStopCall) Do(opts ...googleapi.CallOption) (*StopConnectorResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &StopConnectorResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.connectClusters.connectors.stop", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsOperationsCancelCall struct {
	s                      *Service
	name                   string
	canceloperationrequest *CancelOperationRequest
	urlParams_             gensupport.URLParams
	ctx_                   context.Context
	header_                http.Header
}

// Cancel: Starts asynchronous cancellation on a long-running operation. The
// server makes a best effort to cancel the operation, but success is not
// guaranteed. If the server doesn't support this method, it returns
// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or
// other methods to check whether the cancellation succeeded or whether the
// operation completed despite cancellation. On successful cancellation, the
// operation is not deleted; instead, it becomes an operation with an
// Operation.error value with a google.rpc.Status.code of `1`, corresponding to
// `Code.CANCELLED`.
//
// - name: The name of the operation resource to be cancelled.
func (r *ProjectsLocationsOperationsService) Cancel(name string, canceloperationrequest *CancelOperationRequest) *ProjectsLocationsOperationsCancelCall {
	c := &ProjectsLocationsOperationsCancelCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.canceloperationrequest = canceloperationrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsOperationsCancelCall) Fields(s ...googleapi.Field) *ProjectsLocationsOperationsCancelCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsOperationsCancelCall) Context(ctx context.Context) *ProjectsLocationsOperationsCancelCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsOperationsCancelCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsOperationsCancelCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.canceloperationrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}:cancel")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.cancel", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.operations.cancel" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsOperationsCancelCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.cancel", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsOperationsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Deletes a long-running operation. This method indicates that the
// client is no longer interested in the operation result. It does not cancel
// the operation. If the server doesn't support this method, it returns
// `google.rpc.Code.UNIMPLEMENTED`.
//
// - name: The name of the operation resource to be deleted.
func (r *ProjectsLocationsOperationsService) Delete(name string) *ProjectsLocationsOperationsDeleteCall {
	c := &ProjectsLocationsOperationsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsOperationsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsOperationsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsOperationsDeleteCall) Context(ctx context.Context) *ProjectsLocationsOperationsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsOperationsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsOperationsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.operations.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsOperationsDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsOperationsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Gets the latest state of a long-running operation. Clients can use this
// method to poll the operation result at intervals as recommended by the API
// service.
//
// - name: The name of the operation resource.
func (r *ProjectsLocationsOperationsService) Get(name string) *ProjectsLocationsOperationsGetCall {
	c := &ProjectsLocationsOperationsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsOperationsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsOperationsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsOperationsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsOperationsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsOperationsGetCall) Context(ctx context.Context) *ProjectsLocationsOperationsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsOperationsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsOperationsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.operations.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Operation.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsOperationsGetCall) Do(opts ...googleapi.CallOption) (*Operation, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Operation{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsOperationsListCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Lists operations that match the specified filter in the request. If
// the server doesn't support this method, it returns `UNIMPLEMENTED`.
//
// - name: The name of the operation's parent resource.
func (r *ProjectsLocationsOperationsService) List(name string) *ProjectsLocationsOperationsListCall {
	c := &ProjectsLocationsOperationsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Filter sets the optional parameter "filter": The standard list filter.
func (c *ProjectsLocationsOperationsListCall) Filter(filter string) *ProjectsLocationsOperationsListCall {
	c.urlParams_.Set("filter", filter)
	return c
}

// PageSize sets the optional parameter "pageSize": The standard list page
// size.
func (c *ProjectsLocationsOperationsListCall) PageSize(pageSize int64) *ProjectsLocationsOperationsListCall {
	c.urlParams_.Set("pageSize", fmt.Sprint(pageSize))
	return c
}

// PageToken sets the optional parameter "pageToken": The standard list page
// token.
func (c *ProjectsLocationsOperationsListCall) PageToken(pageToken string) *ProjectsLocationsOperationsListCall {
	c.urlParams_.Set("pageToken", pageToken)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsOperationsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsOperationsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsOperationsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsOperationsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsOperationsListCall) Context(ctx context.Context) *ProjectsLocationsOperationsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsOperationsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsOperationsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/operations")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.operations.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListOperationsResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsOperationsListCall) Do(opts ...googleapi.CallOption) (*ListOperationsResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListOperationsResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.operations.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

// Pages invokes f for each page of results.
// A non-nil error returned from f will halt the iteration.
// The provided context supersedes any context provided to the Context method.
func (c *ProjectsLocationsOperationsListCall) Pages(ctx context.Context, f func(*ListOperationsResponse) error) error {
	c.ctx_ = ctx
	defer c.PageToken(c.urlParams_.Get("pageToken"))
	for {
		x, err := c.Do()
		if err != nil {
			return err
		}
		if err := f(x); err != nil {
			return err
		}
		if x.NextPageToken == "" {
			return nil
		}
		c.PageToken(x.NextPageToken)
	}
}

type ProjectsLocationsSchemaRegistriesCreateCall struct {
	s                           *Service
	parent                      string
	createschemaregistryrequest *CreateSchemaRegistryRequest
	urlParams_                  gensupport.URLParams
	ctx_                        context.Context
	header_                     http.Header
}

// Create: Create a schema registry instance.
//
//   - parent: The parent whose schema registry instance is to be created.
//     Structured like: `projects/{project}/locations/{location}`.
func (r *ProjectsLocationsSchemaRegistriesService) Create(parent string, createschemaregistryrequest *CreateSchemaRegistryRequest) *ProjectsLocationsSchemaRegistriesCreateCall {
	c := &ProjectsLocationsSchemaRegistriesCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.createschemaregistryrequest = createschemaregistryrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesCreateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.createschemaregistryrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/schemaRegistries")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaRegistry.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesCreateCall) Do(opts ...googleapi.CallOption) (*SchemaRegistry, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaRegistry{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete a schema registry instance.
//
//   - name: The name of the schema registry instance to delete. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     `.
func (r *ProjectsLocationsSchemaRegistriesService) Delete(name string) *ProjectsLocationsSchemaRegistriesDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *Empty.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesDeleteCall) Do(opts ...googleapi.CallOption) (*Empty, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Empty{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get the schema registry instance.
//
//   - name: The name of the schema registry instance to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     `.
func (r *ProjectsLocationsSchemaRegistriesService) Get(name string) *ProjectsLocationsSchemaRegistriesGetCall {
	c := &ProjectsLocationsSchemaRegistriesGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaRegistry.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesGetCall) Do(opts ...googleapi.CallOption) (*SchemaRegistry, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaRegistry{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List schema registries.
//
//   - parent: The parent whose schema registry instances are to be listed.
//     Structured like: `projects/{project}/locations/{location}`.
func (r *ProjectsLocationsSchemaRegistriesService) List(parent string) *ProjectsLocationsSchemaRegistriesListCall {
	c := &ProjectsLocationsSchemaRegistriesListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/schemaRegistries")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *ListSchemaRegistriesResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesListCall) Do(opts ...googleapi.CallOption) (*ListSchemaRegistriesResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &ListSchemaRegistriesResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall struct {
	s                         *Service
	name                      string
	checkcompatibilityrequest *CheckCompatibilityRequest
	urlParams_                gensupport.URLParams
	ctx_                      context.Context
	header_                   http.Header
}

// CheckCompatibility: Check compatibility of a schema with all versions or a
// specific version of a subject.
//
//   - name: The name of the resource to check compatibility for. The format is
//     either of following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     compatibility/subjects/*/versions: Check compatibility with one or more
//     versions of the specified subject. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     compatibility/subjects/{subject}/versions/{version}: Check compatibility
//     with a specific version of the subject.
func (r *ProjectsLocationsSchemaRegistriesCompatibilityService) CheckCompatibility(name string, checkcompatibilityrequest *CheckCompatibilityRequest) *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall {
	c := &ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.checkcompatibilityrequest = checkcompatibilityrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.checkcompatibilityrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.compatibility.checkCompatibility", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.compatibility.checkCompatibility" call.
// Any non-2xx status code is an error. Response headers are in either
// *CheckCompatibilityResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesCompatibilityCheckCompatibilityCall) Do(opts ...googleapi.CallOption) (*CheckCompatibilityResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &CheckCompatibilityResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.compatibility.checkCompatibility", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesConfigDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete schema config for a subject.
//
//   - name: The resource name of subject to delete the config for. The format is
//     *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}.
func (r *ProjectsLocationsSchemaRegistriesConfigService) Delete(name string) *ProjectsLocationsSchemaRegistriesConfigDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesConfigDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesConfigDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesConfigDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesConfigDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesConfigDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesConfigDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesConfigDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.config.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesConfigDeleteCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesConfigGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get schema config at global level or for a subject.
//
//   - name: The resource name to get the config for. It can be either of
//     following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config: Get config at global level. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}: Get config for a specific subject.
func (r *ProjectsLocationsSchemaRegistriesConfigService) Get(name string) *ProjectsLocationsSchemaRegistriesConfigGetCall {
	c := &ProjectsLocationsSchemaRegistriesConfigGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// DefaultToGlobal sets the optional parameter "defaultToGlobal": If true, the
// config will fall back to the config at the global level if no subject level
// config is found.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) DefaultToGlobal(defaultToGlobal bool) *ProjectsLocationsSchemaRegistriesConfigGetCall {
	c.urlParams_.Set("defaultToGlobal", fmt.Sprint(defaultToGlobal))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesConfigGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesConfigGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesConfigGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.config.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesConfigGetCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesConfigUpdateCall struct {
	s                         *Service
	name                      string
	updateschemaconfigrequest *UpdateSchemaConfigRequest
	urlParams_                gensupport.URLParams
	ctx_                      context.Context
	header_                   http.Header
}

// Update: Update config at global level or for a subject. Creates a
// SchemaSubject-level SchemaConfig if it does not exist.
//
//   - name: The resource name to update the config for. It can be either of
//     following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config: Update config at global level. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}: Update config for a specific subject.
func (r *ProjectsLocationsSchemaRegistriesConfigService) Update(name string, updateschemaconfigrequest *UpdateSchemaConfigRequest) *ProjectsLocationsSchemaRegistriesConfigUpdateCall {
	c := &ProjectsLocationsSchemaRegistriesConfigUpdateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.updateschemaconfigrequest = updateschemaconfigrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesConfigUpdateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesConfigUpdateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesConfigUpdateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesConfigUpdateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesConfigUpdateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesConfigUpdateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.updateschemaconfigrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PUT", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.update", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.config.update" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesConfigUpdateCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.config.update", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get the context.
//
//   - name: The name of the context to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}`.
func (r *ProjectsLocationsSchemaRegistriesContextsService) Get(name string) *ProjectsLocationsSchemaRegistriesContextsGetCall {
	c := &ProjectsLocationsSchemaRegistriesContextsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Context.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsGetCall) Do(opts ...googleapi.CallOption) (*Context, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Context{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List contexts for a schema registry.
//
//   - parent: The parent of the contexts. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     `.
func (r *ProjectsLocationsSchemaRegistriesContextsService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/contexts")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall struct {
	s                         *Service
	name                      string
	checkcompatibilityrequest *CheckCompatibilityRequest
	urlParams_                gensupport.URLParams
	ctx_                      context.Context
	header_                   http.Header
}

// CheckCompatibility: Check compatibility of a schema with all versions or a
// specific version of a subject.
//
//   - name: The name of the resource to check compatibility for. The format is
//     either of following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     compatibility/subjects/*/versions: Check compatibility with one or more
//     versions of the specified subject. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     compatibility/subjects/{subject}/versions/{version}: Check compatibility
//     with a specific version of the subject.
func (r *ProjectsLocationsSchemaRegistriesContextsCompatibilityService) CheckCompatibility(name string, checkcompatibilityrequest *CheckCompatibilityRequest) *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall {
	c := &ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.checkcompatibilityrequest = checkcompatibilityrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.checkcompatibilityrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.compatibility.checkCompatibility", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.compatibility.checkCompatibility" call.
// Any non-2xx status code is an error. Response headers are in either
// *CheckCompatibilityResponse.ServerResponse.Header or (if a response was
// returned at all) in error.(*googleapi.Error).Header. Use
// googleapi.IsNotModified to check whether the returned error was because
// http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsCompatibilityCheckCompatibilityCall) Do(opts ...googleapi.CallOption) (*CheckCompatibilityResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &CheckCompatibilityResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.compatibility.checkCompatibility", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete schema config for a subject.
//
//   - name: The resource name of subject to delete the config for. The format is
//     *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}.
func (r *ProjectsLocationsSchemaRegistriesContextsConfigService) Delete(name string) *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.config.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigDeleteCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsConfigGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get schema config at global level or for a subject.
//
//   - name: The resource name to get the config for. It can be either of
//     following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config: Get config at global level. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}: Get config for a specific subject.
func (r *ProjectsLocationsSchemaRegistriesContextsConfigService) Get(name string) *ProjectsLocationsSchemaRegistriesContextsConfigGetCall {
	c := &ProjectsLocationsSchemaRegistriesContextsConfigGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// DefaultToGlobal sets the optional parameter "defaultToGlobal": If true, the
// config will fall back to the config at the global level if no subject level
// config is found.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) DefaultToGlobal(defaultToGlobal bool) *ProjectsLocationsSchemaRegistriesContextsConfigGetCall {
	c.urlParams_.Set("defaultToGlobal", fmt.Sprint(defaultToGlobal))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsConfigGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsConfigGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsConfigGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.config.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigGetCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall struct {
	s                         *Service
	name                      string
	updateschemaconfigrequest *UpdateSchemaConfigRequest
	urlParams_                gensupport.URLParams
	ctx_                      context.Context
	header_                   http.Header
}

// Update: Update config at global level or for a subject. Creates a
// SchemaSubject-level SchemaConfig if it does not exist.
//
//   - name: The resource name to update the config for. It can be either of
//     following: *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config: Update config at global level. *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     config/{subject}: Update config for a specific subject.
func (r *ProjectsLocationsSchemaRegistriesContextsConfigService) Update(name string, updateschemaconfigrequest *UpdateSchemaConfigRequest) *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall {
	c := &ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.updateschemaconfigrequest = updateschemaconfigrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.updateschemaconfigrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PUT", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.update", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.config.update" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaConfig.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsConfigUpdateCall) Do(opts ...googleapi.CallOption) (*SchemaConfig, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaConfig{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.config.update", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsModeGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get mode at global level or for a subject.
//
//   - name: The resource name of the mode. The format is *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     mode/{subject}: mode for a schema registry, or *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     contexts/{context}/mode/{subject}: mode for a specific subject in a
//     specific context.
func (r *ProjectsLocationsSchemaRegistriesContextsModeService) Get(name string) *ProjectsLocationsSchemaRegistriesContextsModeGetCall {
	c := &ProjectsLocationsSchemaRegistriesContextsModeGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsModeGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsModeGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsModeGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.mode.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.mode.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaMode.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsModeGetCall) Do(opts ...googleapi.CallOption) (*SchemaMode, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaMode{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.mode.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsModeUpdateCall struct {
	s                       *Service
	name                    string
	updateschemamoderequest *UpdateSchemaModeRequest
	urlParams_              gensupport.URLParams
	ctx_                    context.Context
	header_                 http.Header
}

// Update: Update mode at global level or for a subject.
//
//   - name: The resource name of the mode. The format is *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     mode/{subject}: mode for a schema registry, or *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     contexts/{context}/mode/{subject}: mode for a specific subject in a
//     specific context.
func (r *ProjectsLocationsSchemaRegistriesContextsModeService) Update(name string, updateschemamoderequest *UpdateSchemaModeRequest) *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall {
	c := &ProjectsLocationsSchemaRegistriesContextsModeUpdateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.updateschemamoderequest = updateschemamoderequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.updateschemamoderequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PUT", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.mode.update", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.mode.update" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaMode.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsModeUpdateCall) Do(opts ...googleapi.CallOption) (*SchemaMode, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaMode{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.mode.update", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSchemasGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get the schema for the given schema id.
//
//   - name: The name of the schema to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSchemasService) Get(name string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSchemasGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Subject sets the optional parameter "subject": Used to limit the search for
// the schema ID to a specific subject, otherwise the schema ID will be
// searched for in all subjects in the given specified context.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.schemas.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Schema.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetCall) Do(opts ...googleapi.CallOption) (*Schema, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Schema{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// GetSchema: Get the schema string for the given schema id. The response will
// be the schema string.
//
//   - name: The name of the schema to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSchemasService) GetSchema(name string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Subject sets the optional parameter "subject": Used to limit the search for
// the schema ID to a specific subject, otherwise the schema ID will be
// searched for in all subjects in the given specified context.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/schema")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.getSchema", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.schemas.getSchema" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasGetSchemaCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.getSchema", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List subjects which reference a particular schema id. The response
// will be an array of subject names.
//
//   - parent: The schema resource whose associated subjects are to be listed.
//     Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted subjects. The default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Subject sets the optional parameter "subject": The subject to filter the
// subjects by.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/subjects")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.subjects.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.schemas.subjects.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasSubjectsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.subjects.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List the supported schema types. The response will be an array of
// schema types.
//
//   - parent: The parent schema registry whose schema types are to be listed.
//     Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     `.
func (r *ProjectsLocationsSchemaRegistriesContextsSchemasTypesService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/schemas/types")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.types.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.schemas.types.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasTypesListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.types.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List the schema versions for the given schema id. The response will be
// an array of subject-version pairs as: [{"subject":"subject1", "version":1},
// {"subject":"subject2", "version":2}].
//
//   - parent: The schema whose schema versions are to be listed. Structured
//     like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted versions of the schema, even if the subject is
// soft-deleted. The default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Subject sets the optional parameter "subject": The subject to filter the
// subjects by.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.versions.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.schemas.versions.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSchemasVersionsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.schemas.versions.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete a subject. The response will be an array of versions of the
// deleted subject.
//
//   - name: The name of the subject to delete. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsService) Delete(name string) *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Permanent sets the optional parameter "permanent": If true, the subject and
// all associated metadata including the schema ID will be deleted permanently.
// Otherwise, only the subject is soft-deleted. The default is false.
// Soft-deleted subjects can still be searched in ListSubjects API call with
// deleted=true query parameter. A soft-delete of a subject must be performed
// before a hard-delete.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) Permanent(permanent bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall {
	c.urlParams_.Set("permanent", fmt.Sprint(permanent))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsDeleteCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List subjects in the schema registry. The response will be an array of
// subject names.
//
//   - parent: The parent schema registry/context whose subjects are to be
//     listed. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     ` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted subjects. The default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// SubjectPrefix sets the optional parameter "subjectPrefix": The context to
// filter the subjects by, in the format of `:.{context}:`. If unset, all
// subjects in the registry are returned. Set to empty string or add as
// '?subjectPrefix=' at the end of this request to list subjects in the default
// context.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) SubjectPrefix(subjectPrefix string) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c.urlParams_.Set("subjectPrefix", subjectPrefix)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/subjects")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall struct {
	s                    *Service
	parent               string
	lookupversionrequest *LookupVersionRequest
	urlParams_           gensupport.URLParams
	ctx_                 context.Context
	header_              http.Header
}

// LookupVersion: Lookup a schema under the specified subject.
//
//   - parent: The subject to lookup the schema in. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsService) LookupVersion(parent string, lookupversionrequest *LookupVersionRequest) *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.lookupversionrequest = lookupversionrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.lookupversionrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.lookupVersion", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.lookupVersion" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaVersion.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsLookupVersionCall) Do(opts ...googleapi.CallOption) (*SchemaVersion, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaVersion{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.lookupVersion", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall struct {
	s                    *Service
	parent               string
	createversionrequest *CreateVersionRequest
	urlParams_           gensupport.URLParams
	ctx_                 context.Context
	header_              http.Header
}

// Create: Register a new version under a given subject with the given schema.
//
//   - parent: The subject to create the version for. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService) Create(parent string, createversionrequest *CreateVersionRequest) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.createversionrequest = createversionrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.createversionrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *CreateVersionResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsCreateCall) Do(opts ...googleapi.CallOption) (*CreateVersionResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &CreateVersionResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete a version of a subject. The response will be the deleted
// version id.
//
//   - name: The name of the subject version to delete. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService) Delete(name string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Permanent sets the optional parameter "permanent": If true, both the version
// and the referenced schema ID will be permanently deleted. The default is
// false. If false, the version will be deleted but the schema ID will be
// retained. Soft-deleted versions can still be searched in ListVersions API
// call with deleted=true query parameter. A soft-delete of a version must be
// performed before a hard-delete.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) Permanent(permanent bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall {
	c.urlParams_.Set("permanent", fmt.Sprint(permanent))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsDeleteCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get a versioned schema (schema with subject/version) of a subject.
//
//   - name: The name of the subject to return versions. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService) Get(name string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Deleted sets the optional parameter "deleted": If true, no matter if the
// subject/version is soft-deleted or not, it returns the version details. If
// false, it returns NOT_FOUND error if the subject/version is soft-deleted.
// The default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaVersion.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetCall) Do(opts ...googleapi.CallOption) (*SchemaVersion, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaVersion{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// GetSchema: Get the schema string only for a version of a subject. The
// response will be the schema string.
//
//   - name: The name of the subject to return versions. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService) GetSchema(name string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Deleted sets the optional parameter "deleted": If true, no matter if the
// subject/version is soft-deleted or not, it returns the version details. If
// false, it returns NOT_FOUND error if the subject/version is soft-deleted.
// The default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/schema")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.getSchema", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.getSchema" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsGetSchemaCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.getSchema", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Get all versions of a subject. The response will be an array of
// versions of the subject.
//
//   - parent: The subject whose versions are to be listed. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted versions of an active or soft-deleted subject. The
// default is false.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Get a list of IDs of schemas that reference the schema with the given
// subject and version.
//
//   - parent: The version to list referenced by. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyService) List(parent string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall {
	c := &ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/referencedby")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.referencedby.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.referencedby.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesContextsSubjectsVersionsReferencedbyListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.contexts.subjects.versions.referencedby.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesModeGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get mode at global level or for a subject.
//
//   - name: The resource name of the mode. The format is *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     mode/{subject}: mode for a schema registry, or *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     contexts/{context}/mode/{subject}: mode for a specific subject in a
//     specific context.
func (r *ProjectsLocationsSchemaRegistriesModeService) Get(name string) *ProjectsLocationsSchemaRegistriesModeGetCall {
	c := &ProjectsLocationsSchemaRegistriesModeGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesModeGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesModeGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesModeGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesModeGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesModeGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesModeGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesModeGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesModeGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.mode.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.mode.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaMode.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesModeGetCall) Do(opts ...googleapi.CallOption) (*SchemaMode, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaMode{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.mode.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesModeUpdateCall struct {
	s                       *Service
	name                    string
	updateschemamoderequest *UpdateSchemaModeRequest
	urlParams_              gensupport.URLParams
	ctx_                    context.Context
	header_                 http.Header
}

// Update: Update mode at global level or for a subject.
//
//   - name: The resource name of the mode. The format is *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     mode/{subject}: mode for a schema registry, or *
//     projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/
//     contexts/{context}/mode/{subject}: mode for a specific subject in a
//     specific context.
func (r *ProjectsLocationsSchemaRegistriesModeService) Update(name string, updateschemamoderequest *UpdateSchemaModeRequest) *ProjectsLocationsSchemaRegistriesModeUpdateCall {
	c := &ProjectsLocationsSchemaRegistriesModeUpdateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	c.updateschemamoderequest = updateschemamoderequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesModeUpdateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesModeUpdateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesModeUpdateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesModeUpdateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesModeUpdateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesModeUpdateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.updateschemamoderequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("PUT", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.mode.update", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.mode.update" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaMode.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesModeUpdateCall) Do(opts ...googleapi.CallOption) (*SchemaMode, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaMode{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.mode.update", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSchemasGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get the schema for the given schema id.
//
//   - name: The name of the schema to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesSchemasService) Get(name string) *ProjectsLocationsSchemaRegistriesSchemasGetCall {
	c := &ProjectsLocationsSchemaRegistriesSchemasGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Subject sets the optional parameter "subject": Used to limit the search for
// the schema ID to a specific subject, otherwise the schema ID will be
// searched for in all subjects in the given specified context.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesSchemasGetCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSchemasGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSchemasGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSchemasGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.schemas.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *Schema.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetCall) Do(opts ...googleapi.CallOption) (*Schema, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &Schema{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// GetSchema: Get the schema string for the given schema id. The response will
// be the schema string.
//
//   - name: The name of the schema to return. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesSchemasService) GetSchema(name string) *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall {
	c := &ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Subject sets the optional parameter "subject": Used to limit the search for
// the schema ID to a specific subject, otherwise the schema ID will be
// searched for in all subjects in the given specified context.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/schema")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.getSchema", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.schemas.getSchema" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSchemasGetSchemaCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.getSchema", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List subjects which reference a particular schema id. The response
// will be an array of subject names.
//
//   - parent: The schema resource whose associated subjects are to be listed.
//     Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesSchemasSubjectsService) List(parent string) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c := &ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted subjects. The default is false.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Subject sets the optional parameter "subject": The subject to filter the
// subjects by.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/subjects")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.subjects.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.schemas.subjects.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSchemasSubjectsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.subjects.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSchemasTypesListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List the supported schema types. The response will be an array of
// schema types.
//
//   - parent: The parent schema registry whose schema types are to be listed.
//     Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     `.
func (r *ProjectsLocationsSchemaRegistriesSchemasTypesService) List(parent string) *ProjectsLocationsSchemaRegistriesSchemasTypesListCall {
	c := &ProjectsLocationsSchemaRegistriesSchemasTypesListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSchemasTypesListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSchemasTypesListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSchemasTypesListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/schemas/types")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.types.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.schemas.types.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSchemasTypesListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.types.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSchemasVersionsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List the schema versions for the given schema id. The response will be
// an array of subject-version pairs as: [{"subject":"subject1", "version":1},
// {"subject":"subject2", "version":2}].
//
//   - parent: The schema whose schema versions are to be listed. Structured
//     like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /schemas/ids/{schema}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/schemas/ids/{schema}`.
func (r *ProjectsLocationsSchemaRegistriesSchemasVersionsService) List(parent string) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c := &ProjectsLocationsSchemaRegistriesSchemasVersionsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted versions of the schema, even if the subject is
// soft-deleted. The default is false.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Subject sets the optional parameter "subject": The subject to filter the
// subjects by.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Subject(subject string) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c.urlParams_.Set("subject", subject)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.versions.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.schemas.versions.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSchemasVersionsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.schemas.versions.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete a subject. The response will be an array of versions of the
// deleted subject.
//
//   - name: The name of the subject to delete. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsService) Delete(name string) *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Permanent sets the optional parameter "permanent": If true, the subject and
// all associated metadata including the schema ID will be deleted permanently.
// Otherwise, only the subject is soft-deleted. The default is false.
// Soft-deleted subjects can still be searched in ListSubjects API call with
// deleted=true query parameter. A soft-delete of a subject must be performed
// before a hard-delete.
func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) Permanent(permanent bool) *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall {
	c.urlParams_.Set("permanent", fmt.Sprint(permanent))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsDeleteCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: List subjects in the schema registry. The response will be an array of
// subject names.
//
//   - parent: The parent schema registry/context whose subjects are to be
//     listed. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     ` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsService) List(parent string) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted subjects. The default is false.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// SubjectPrefix sets the optional parameter "subjectPrefix": The context to
// filter the subjects by, in the format of `:.{context}:`. If unset, all
// subjects in the registry are returned. Set to empty string or add as
// '?subjectPrefix=' at the end of this request to list subjects in the default
// context.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) SubjectPrefix(subjectPrefix string) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c.urlParams_.Set("subjectPrefix", subjectPrefix)
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/subjects")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall struct {
	s                    *Service
	parent               string
	lookupversionrequest *LookupVersionRequest
	urlParams_           gensupport.URLParams
	ctx_                 context.Context
	header_              http.Header
}

// LookupVersion: Lookup a schema under the specified subject.
//
//   - parent: The subject to lookup the schema in. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsService) LookupVersion(parent string, lookupversionrequest *LookupVersionRequest) *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.lookupversionrequest = lookupversionrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.lookupversionrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.lookupVersion", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.lookupVersion" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaVersion.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsLookupVersionCall) Do(opts ...googleapi.CallOption) (*SchemaVersion, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaVersion{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.lookupVersion", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall struct {
	s                    *Service
	parent               string
	createversionrequest *CreateVersionRequest
	urlParams_           gensupport.URLParams
	ctx_                 context.Context
	header_              http.Header
}

// Create: Register a new version under a given subject with the given schema.
//
//   - parent: The subject to create the version for. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsService) Create(parent string, createversionrequest *CreateVersionRequest) *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	c.createversionrequest = createversionrequest
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "application/json", c.header_)
	body, err := googleapi.WithoutDataWrapper.JSONBuffer(c.createversionrequest)
	if err != nil {
		return nil, err
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("POST", urls, body)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.create", "request", internallog.HTTPRequest(req, body.Bytes()))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.create" call.
// Any non-2xx status code is an error. Response headers are in either
// *CreateVersionResponse.ServerResponse.Header or (if a response was returned
// at all) in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to
// check whether the returned error was because http.StatusNotModified was
// returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsCreateCall) Do(opts ...googleapi.CallOption) (*CreateVersionResponse, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &CreateVersionResponse{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.create", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall struct {
	s          *Service
	name       string
	urlParams_ gensupport.URLParams
	ctx_       context.Context
	header_    http.Header
}

// Delete: Delete a version of a subject. The response will be the deleted
// version id.
//
//   - name: The name of the subject version to delete. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsService) Delete(name string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Permanent sets the optional parameter "permanent": If true, both the version
// and the referenced schema ID will be permanently deleted. The default is
// false. If false, the version will be deleted but the schema ID will be
// retained. Soft-deleted versions can still be searched in ListVersions API
// call with deleted=true query parameter. A soft-delete of a version must be
// performed before a hard-delete.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) Permanent(permanent bool) *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall {
	c.urlParams_.Set("permanent", fmt.Sprint(permanent))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("DELETE", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.delete", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.delete" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsDeleteCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.delete", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// Get: Get a versioned schema (schema with subject/version) of a subject.
//
//   - name: The name of the subject to return versions. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsService) Get(name string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Deleted sets the optional parameter "deleted": If true, no matter if the
// subject/version is soft-deleted or not, it returns the version details. If
// false, it returns NOT_FOUND error if the subject/version is soft-deleted.
// The default is false.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.get", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.get" call.
// Any non-2xx status code is an error. Response headers are in either
// *SchemaVersion.ServerResponse.Header or (if a response was returned at all)
// in error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetCall) Do(opts ...googleapi.CallOption) (*SchemaVersion, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &SchemaVersion{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.get", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall struct {
	s            *Service
	name         string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// GetSchema: Get the schema string only for a version of a subject. The
// response will be the schema string.
//
//   - name: The name of the subject to return versions. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsService) GetSchema(name string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.name = name
	return c
}

// Deleted sets the optional parameter "deleted": If true, no matter if the
// subject/version is soft-deleted or not, it returns the version details. If
// false, it returns NOT_FOUND error if the subject/version is soft-deleted.
// The default is false.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+name}/schema")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"name": c.name,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.getSchema", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.getSchema" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsGetSchemaCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.getSchema", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Get all versions of a subject. The response will be an array of
// versions of the subject.
//
//   - parent: The subject whose versions are to be listed. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsService) List(parent string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Deleted sets the optional parameter "deleted": If true, the response will
// include soft-deleted versions of an active or soft-deleted subject. The
// default is false.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) Deleted(deleted bool) *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall {
	c.urlParams_.Set("deleted", fmt.Sprint(deleted))
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/versions")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}

type ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall struct {
	s            *Service
	parent       string
	urlParams_   gensupport.URLParams
	ifNoneMatch_ string
	ctx_         context.Context
	header_      http.Header
}

// List: Get a list of IDs of schemas that reference the schema with the given
// subject and version.
//
//   - parent: The version to list referenced by. Structured like:
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /subjects/{subject}/versions/{version}` or
//     `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}
//     /contexts/{context}/subjects/{subject}/versions/{version}`.
func (r *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyService) List(parent string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall {
	c := &ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall{s: r.s, urlParams_: make(gensupport.URLParams)}
	c.parent = parent
	return c
}

// Fields allows partial responses to be retrieved. See
// https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more
// details.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) Fields(s ...googleapi.Field) *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall {
	c.urlParams_.Set("fields", googleapi.CombineFields(s))
	return c
}

// IfNoneMatch sets an optional parameter which makes the operation fail if the
// object's ETag matches the given value. This is useful for getting updates
// only after the object has changed since the last request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) IfNoneMatch(entityTag string) *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall {
	c.ifNoneMatch_ = entityTag
	return c
}

// Context sets the context to be used in this call's Do method.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) Context(ctx context.Context) *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall {
	c.ctx_ = ctx
	return c
}

// Header returns a http.Header that can be modified by the caller to add
// headers to the request.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) Header() http.Header {
	if c.header_ == nil {
		c.header_ = make(http.Header)
	}
	return c.header_
}

func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) doRequest(alt string) (*http.Response, error) {
	reqHeaders := gensupport.SetHeaders(c.s.userAgent(), "", c.header_)
	if c.ifNoneMatch_ != "" {
		reqHeaders.Set("If-None-Match", c.ifNoneMatch_)
	}
	c.urlParams_.Set("alt", alt)
	c.urlParams_.Set("prettyPrint", "false")
	urls := googleapi.ResolveRelative(c.s.BasePath, "v1/{+parent}/referencedby")
	urls += "?" + c.urlParams_.Encode()
	req, err := http.NewRequest("GET", urls, nil)
	if err != nil {
		return nil, err
	}
	req.Header = reqHeaders
	googleapi.Expand(req.URL, map[string]string{
		"parent": c.parent,
	})
	c.s.logger.DebugContext(c.ctx_, "api request", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.referencedby.list", "request", internallog.HTTPRequest(req, nil))
	return gensupport.SendRequest(c.ctx_, c.s.client, req)
}

// Do executes the "managedkafka.projects.locations.schemaRegistries.subjects.versions.referencedby.list" call.
// Any non-2xx status code is an error. Response headers are in either
// *HttpBody.ServerResponse.Header or (if a response was returned at all) in
// error.(*googleapi.Error).Header. Use googleapi.IsNotModified to check
// whether the returned error was because http.StatusNotModified was returned.
func (c *ProjectsLocationsSchemaRegistriesSubjectsVersionsReferencedbyListCall) Do(opts ...googleapi.CallOption) (*HttpBody, error) {
	gensupport.SetOptions(c.urlParams_, opts...)
	res, err := c.doRequest("json")
	if res != nil && res.StatusCode == http.StatusNotModified {
		if res.Body != nil {
			res.Body.Close()
		}
		return nil, gensupport.WrapError(&googleapi.Error{
			Code:   res.StatusCode,
			Header: res.Header,
		})
	}
	if err != nil {
		return nil, err
	}
	defer googleapi.CloseBody(res)
	if err := googleapi.CheckResponse(res); err != nil {
		return nil, gensupport.WrapError(err)
	}
	ret := &HttpBody{
		ServerResponse: googleapi.ServerResponse{
			Header:         res.Header,
			HTTPStatusCode: res.StatusCode,
		},
	}
	target := &ret
	b, err := gensupport.DecodeResponseBytes(target, res)
	if err != nil {
		return nil, err
	}
	c.s.logger.DebugContext(c.ctx_, "api response", "serviceName", apiName, "rpcName", "managedkafka.projects.locations.schemaRegistries.subjects.versions.referencedby.list", "response", internallog.HTTPResponse(res, b))
	return ret, nil
}
